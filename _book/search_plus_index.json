{"./":{"url":"./","title":"Introduction","keywords":"","body":"这个gitbook用于学习和基础知识的积累 "},"javaScript/":{"url":"javaScript/","title":"javaScript深入浅出","keywords":"","body":"javaScript "},"javaScript/mouse.html":{"url":"javaScript/mouse.html","title":"获取鼠标的坐标位置","keywords":"","body":"获取鼠标的位置 获取鼠标的位置可以分为多个情况 获取鼠标相对于浏览器窗口的位置 let x = event.clientX; let y = event.clientY; 获取鼠标相对于整个页面的位置 let x = event.pageX; let y = event.pageY; 获取鼠标相对点击元素的位置 这一个获取有点难度，因为在JavaScript原生方法中没有这个方法，那么需要分析如何获取，突破点一获取点击元素的相对其父本元素的偏移量这个属性在event的target属性下边绑定可以循环的方法获取点击元素相对于页面的位置方法如下 /* *该方法是获取点击元素相对于页面的距离 *传入的参数为event.target */ function getOffset(obj){ var tmp={ val:obj.offsetParent, //获取点击元素的父本 x:obj.offsetLeft, //获取点击元素的相对于父本的水平偏移 y:obj.offsetTop, //获取点击元素的相对于父本的垂直偏移 } while(tmp.val != null){ //当父级不存在是停止循环 tmp.x += tmp.val.offsetLeft; //水平偏移量累计 tmp.y += tmp.val.offsetTop; //垂直偏移量累计 tmp.val = tmp.val.offsetParent; //获取父本 } return tmp; //返回点击元素相对于页面的偏移值 } 以上函数是获取了点击元素相对于页面的水平和垂直偏移，依赖以上获得的值，只需要鼠标相对于页面的偏移减去点击元素相对于页面的偏移方法如下： /* *该方法是获取鼠标相对于点击元素的位移 *传入的参数为event */ function getCurrent(elem){ let off = getOffset(elem.target); //获取元素相对于页面的位置 let tmp = {}; return tmp = { x:elem.pageX - off.x, y:elem.pageY - off.y } } 3.getBoundingClientRect用于获取某个html元素相对于页面的位置集合 执行 object.getBoundingClientRect();会得到元素的top、right、bottom、left、width、height属性，这些属性以一个对象的方式返回。 主要是left和bottom要解释一下，left是指右边到页面最左边的距离，bottom是指底边到页面顶边的距离。 (ie5以上都能支持，但是又一点点地方需要修正一下，IE67的left、top会少2px,并且没有width、height属性。) function getObjXy(obj){ var xy = obj.getBoundingClientRect(); var top = xy.top-document.documentElement.clientTop+document.documentElement.scrollTop,//document.documentElement.clientTop 在IE67中始终为2，其他高级点的浏览器为0 bottom = xy.bottom, left = xy.left-document.documentElement.clientLeft+document.documentElement.scrollLeft,//document.documentElement.clientLeft 在IE67中始终为2，其他高级点的浏览器为0 right = xy.right, width = xy.width||right - left, //IE67不存在width 使用right - left获得 height = xy.height||bottom - top; return { top:top, right:right, bottom:bottom, left:left, width:width, height:height } } var test = getObjXy(document.getElementById('test')); alert(\"top:\" + test.top + \", right:\" + test.right + \", bottom:\" + test.bottom + \", left:\" + test.left); 以上就是常用的获取鼠标位置的方法 "},"javaScript/promise.html":{"url":"javaScript/promise.html","title":"promise原理解析","keywords":"","body":"promise原理解析 promise模式 这几种方式的可维护性逐级递增，理解难度也逐级递增。这篇总结也是针对promise模式的。 promise模式那么多中异步编程的方式，为什么选择promise, 因为前面几种方式不够灵活，用起来不够痛快，不优雅。为了降低异步编程的复杂性，所以promise。 promise的核心是有一个promise对象，这个对象有一个重要的then()方法, 它用于指定回调函数，如： f1().then(f2); promise模式在任何时刻都有三种状态：已完成（resolved），未完成（unfulfilled），那么then()方法就是为状态变化指定不同的回调函数，并总是返回一个promise对象，方便链式调用。 那promise模式下，返回的数据如何在各个回调函数之间传播呢，通过resolve方法，你可以将一个函数的返回值作为参数传递给另一个函数，并且将另一个函数的返回值作为参数再传递给下一个函数……像一条“链”一样无限的这么做下去。 代码如下： //constructor var promise = function() { this.callbacks = []; } promise.prototype = { construct: promise, //成功的操作 resolve: function(result) { this.complete('resolve', result); }, //失败 reject: function(result) { this.complete(\"reject\", result); }, //执行回调 complete: function(type, result) { while(this.callbacks[0]) { this.callbacks.shift()[type](result); } }, then: function(successHandler, failedHandler) { this.callbacks.push({ resolve: successHandler, reject: failedHandler }); return this; } } //运行下边是方法的调用 var pro = new promise(); var delay1 = function() { setTimeout(function() { pro.resolve('数据1'); }, 1000); return pro; }; var callback1 = function(re) { re = re + '数据2'; console.log(re); }; delay1().then(callback1) console.log(\"我是最后吗\"); /* *以上方法输出的结果分别是 *我是最后吗 *数据1 *数据2 */ 代码分析 我们可看到一个简单的promise对象的构造函数的结构： callbacks: 用于管理回调函数 resolve: 请求成功时执行的方法 reject:请求失败时执行的方法 complete: 执行回调 then：绑定回调函数 第一步 var delay1 = function() { setTimeout(function() { promise.resolve(‘数据1’); }, 1000); return promise; }; //这个函数通过setTimeout方法， 异步传递一个数据1， 并返回一个promise对象(必须)。 第二步 var callback1 = function(re) { re = re + '数据2'; console.log(re); promise.resolve(re); }; //callback1和callback2都是要通过then方法注册的回调函数， 其中callback1通过resolve方法把数据往下传递。 第三步 delay1().then(callback1).then(callback2); //delay1() 方法执行完， 因为返回了一个promise对象， 所以可以再调用then() 方法为delay1() 的setTimeout异步执行操作指定回调函数, 又因为then() 方法也返回的是promise对象， 所以还可以再调用then方法 第四步 setTimeout(function() { promise.resolve('数据1'); }, 1000); //一秒之后， 当其他代码执行完成， 开始执行异步代码promise.resolve(‘数据1’);， //这里调用promise的resolve() 方法， 指定了一个成功状态， 并把数据1作为参数。 第五步 resolve: function(result) { this.complete(\"resolve\", result); }, 第六步：循环执行回调，将上一个回调的结果传递给下一个回调 complete: function(type, result) { while(this.callbacks[0]) { this.callbacks.shift()[type](result); } }, "},"javaScript/router.html":{"url":"javaScript/router.html","title":"路由实现原理解析","keywords":"","body":"路由实现原理解析 原文地址 在单页应用上，前端路由并不陌生。很多前端框架也会有独立开发或推荐配套使用的路由系统。那么，当我们在谈前端路由的时候，还可以谈些什么？本文将简要分析并实现一个的前端路由，并对 react-router 进行分析。 一个极简前端路由实现 说一下前端路由实现的简要原理，以 hash 形式（也可以使用 History API 来处理）为例，当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。直接看代码或许更直观。 function Router() { this.routes = {}; this.currentUrl = ''; } Router.prototype.route = function(path, callback) { this.routes[path] = callback || function(){}; }; Router.prototype.refresh = function() { this.currentUrl = location.hash.slice(1) || '/'; this.routes[this.currentUrl](); }; Router.prototype.init = function() { window.addEventListener('load', this.refresh.bind(this), false); window.addEventListener('hashchange', this.refresh.bind(this), false); } window.Router = new Router(); window.Router.init(); 上面路由系统 Router 对象实现，主要提供三个方法 init 监听浏览器 url hash 更新事件 route 存储路由更新时的回调到回调数组routes中，回调函数将负责对页面的更新 refresh 执行当前url对应的回调函数，更新页面 Router 调用方式以及呈现效果如下：点击触发 url 的 hash 改变，并对应地更新内容（这里为 body 背景色） turn white turn blue turn green var content = document.querySelector('body'); // change Page anything function changeBgColor(color) { content.style.backgroundColor = color; } Router.route('/', function() { changeBgColor('white'); }); Router.route('/blue', function() { changeBgColor('blue'); }); Router.route('/green', function() { changeBgColor('green'); }); 以上为一个前端路由的简单实现，点击查看完整代码，虽然简单，但实际上很多路由系统的根基都立于此，其他路由系统主要是对自身使用的框架机制的进行配套及优化，如与 react 配套的 react-router。 react-router 分析 react-router 与 history 结合形式 react-router 是基于 history 模块提供的 api 进行开发的，结合的形式本文记为 包装方式。所以在开始对其分析之前，先举一个简单的例子来说明如何进行对象的包装。 // 原对象 var historyModule = { listener: [], listen: function (listener) { this.listener.push(listener); console.log('historyModule listen..') }, updateLocation: function(){ this.listener.forEach(function(listener){ listener('new localtion'); }) } } // Router 将使用 historyModule 对象，并对其包装 var Router = { source: {}, init: function(source){ this.source = source; }, // 对 historyModule的listen进行了一层包装 listen: function(listener) { return this.source.listen(function(location){ console.log('Router listen tirgger.'); listener(location); }) } } // 将 historyModule 注入进 Router 中 Router.init(historyModule); // Router 注册监听 Router.listen(function(location){ console.log(location + '-> Router setState.'); }) // historyModule 触发回调 historyModule.updateLocation(); 返回： 22 可看到 historyModule 中含有机制：historyModule.updateLocation() -> listener( )，Router 通过对其进行包装开发，针对 historyModule 的机制对 Router 也起到了作用，即historyModule.updateLocation() 将触发 Router.listen 中的回调函数 。点击查看完整代码 这种包装形式能够充分利用原对象（historyModule ）的内部机制，减少开发成本，也更好的分离包装函数（Router）的逻辑，减少对原对象的影响。 react-router 使用方式 react-router 以 react component 的组件方式提供 API， 包含 Router，Route，Redirect，Link 等等，这样能够充分利用 react component 提供的生命周期特性，同时也让定义路由跟写 react component 达到统一，如下 render(( ), document.body) 就这样，声明了一份含有 path to component 的各个映射的路由表。 react-router 还提供的 Link 组件（如下），作为提供更新 url 的途径，触发 Link 后最终将通过如上面定义的路由表进行匹配，并拿到对应的 component 及 state 进行 render 渲染页面。 'joey' 这里不细讲 react-router 的使用，详情可见：https://github.com/reactjs/react-router 从点击 Link 到 render 对应 component ，路由中发生了什么 为何能够触发 render component ？ 主要是因为触发了 react setState 的方法从而能够触发 render component。 从顶层组件 Router 出发（下面代码从 react-router/Router 中摘取），可看到 Router 在 react component 生命周期之组件被挂载前 componentWillMount 中使用 this.history.listen 去注册了 url 更新的回调函数。回调函数将在 url 更新时触发，回调中的 setState 起到 render 了新的 component 的作用。 Router.prototype.componentWillMount = function componentWillMount() { // .. 省略其他 var createHistory = this.props.history; this.history = _useRoutes2['default'](createHistory)({ routes: _RouteUtils.createRoutes(routes || children), parseQueryString: parseQueryString, stringifyQuery: stringifyQuery }); this._unlisten = this.history.listen(function (error, state) { _this.setState(state, _this.props.onUpdate); }); }; 上面的 _useRoutes2 对 history 操作便是对其做一层包装，所以调用的 this.history 实际为包装以后的对象，该对象含有 _useRoutes2 中的 listen 方法，如下 function listen(listener) { return history.listen(function (location) { // .. 省略其他 match(location, function (error, redirectLocation, nextState) { listener(null, nextState); }); }); } 可看到，上面代码中，主要分为两部分 使用了 history 模块的 listen 注册了一个含有 setState 的回调函数（这样就能使用 history 模块中的机制） 回调中的 match 方法为 react-router 所特有，match 函数根据当前 location 以及前面写的 Route 路由表匹配出对应的路由子集得到新的路由状态值 state，具体实现可见 react-router/matchRoutes ，再根据 state 得到对应的 component ，最终执行了 match 中的回调 listener(null, nextState) ，即执行了 Router 中的监听回调（setState），从而更新了展示。 以上，为起始注册的监听，及回调的作用。 如何触发监听的回调函数的执行？ 这里还得从如何更新 url 说起。一般来说，url 更新主要有两种方式：简单的 hash 更新或使用 history api 进行地址更新。在 react-router 中，其提供了 Link 组件，该组件能在 render 中使用，最终会表现为 a 标签，并将 Link 中的各个参数组合放它的 href 属性中。可以从 react-router/ Link 中看到，对该组件的点击事件进行了阻止了浏览器的默认跳转行为，而改用 history 模块的 pushState 方法去触发 url 更新。 Link.prototype.render = function render() { // .. 省略其他 props.onClick = function (e) { return _this.handleClick(e); }; if (history) { // .. 省略其他 props.href = history.createHref(to, query); } return _react2['default'].createElement('a', props); }; Link.prototype.handleClick = function handleClick(event) { // .. 省略其他 event.preventDefault(); this.context.history.pushState(this.props.state, this.props.to, this.props.query); }; 对 history 模块的 pushState 方法对 url 的更新形式，同样分为两种，分别在 history/createBrowserHistory 及 history/createHashHistory 各自的 finishTransition 中，如 history/createBrowserHistory 中使用的是 window.history.replaceState(historyState, null, path); 而 history/createHashHistory 则使用 window.location.hash = url，调用哪个是根据我们一开始创建 history 的方式。 更新 url 的显示是一部分，另一部分是根据 url 去更新展示，也就是触发前面的监听。这是在前面 finishTransition 更新 url 之后实现的，调用的是 history/createHistory 中的 updateLocation 方法，changeListeners 中为 history/createHistory 中的 listen 中所添加的，如下 function updateLocation(newLocation) { // 示意代码 location = newLocation; changeListeners.forEach(function (listener) { listener(location); }); } function listen(listener) { // 示意代码 changeListeners.push(listener); } 总结 可以将以上 react-router 的整个包装闭环总结为 回调函数：含有能够更新 react UI 的 react setState 方法。 注册回调：在 Router componentWillMount 中使用 history.listen 注册的回调函数，最终放在 history 模块的 回调函数数组 changeListeners 中。 触发回调：Link 点击触发 history 中回调函数数组 changeListeners 的执行，从而触发原来 listen 中的 setState 方法，更新了页面 至于前进与后退的实现，是通过监听 popstate 以及 hashchange 的事件，当前进或后退 url 更新时，触发这两个事件的回调函数，回调的执行方式 Link 大致相同，最终同样更新了 UI ，这里就不再说明。 react-router 主要是利用底层 history 模块的机制，通过结合 react 的架构机制做一层包装，实际自身的内容并不多，但其包装的思想笔者认为很值得学习，有兴趣的建议阅读下源码，相信会有其他收获。 "},"javaScript/toBottom.html":{"url":"javaScript/toBottom.html","title":"滚到底部加载","keywords":"","body":"滚到底部加载 其实这个功能的实现就是监听滚动条是否滚动到底部，如果滚动到底部则向后后台获取数据废话不多说上代码 浏览器视口的高度 getWindowHeight = () => { 　　var windowHeight = 0; 　　if(document.compatMode == \"CSS1Compat\"){ 　　　　windowHeight = document.documentElement.clientHeight; 　　}else{ 　　　　windowHeight = document.body.clientHeight; 　　} 　　return windowHeight; } 文档的总高度 getScrollHeight = () => { 　　var scrollHeight = 0, bodyScrollHeight = 0, documentScrollHeight = 0; 　　if(document.body){ 　　　　bodyScrollHeight = document.body.scrollHeight; 　　} 　　if(document.documentElement){ 　　　　documentScrollHeight = document.documentElement.scrollHeight; 　　} 　　scrollHeight = (bodyScrollHeight - documentScrollHeight > 0) ? bodyScrollHeight : documentScrollHeight; 　　return scrollHeight; } 滚动条在Y轴上的滚动距离 getScrollTop = () => { 　　var scrollTop = 0, bodyScrollTop = 0, documentScrollTop = 0; 　　if(document.body){ 　　　　bodyScrollTop = document.body.scrollTop; 　　} 　　if(document.documentElement){ 　　　　documentScrollTop = document.documentElement.scrollTop; 　　} 　　scrollTop = (bodyScrollTop - documentScrollTop > 0) ? bodyScrollTop : documentScrollTop; 　　return scrollTop; } 那么剩下的就是在js里边进行判断这里主要说在react里的用法 这里把所有的操作写在一个方法里 onScrollListener = () =>{ if(getScrollTop() + getWindowHeight() == getScrollHeight()){ alert(\"滚动条已经滚动到了底部\"); } } 在react的componentDidMount生命周期里写一下代码 componentDidMount(){ //滚轮监听 addEventListener(\"scroll\",this.onscrollListener,false) } 在react的componentWillUnmount生命周期里写一下代码(注册事件要在组件销毁以后注销这样可以提高性能) componentWillUnmount(){ window.removeEventListener(\"scroll\",this.onscrollListener) } "},"javaScript/prototype.html":{"url":"javaScript/prototype.html","title":"原型到原型链","keywords":"","body":"原型到原型链 构造函数创建对象 我们先使用构造函数创建一个对象： function Person() { } var person = new Person(); person.name = 'Kevin'; console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype 每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： function Person() { } // 虽然写在注释里，但是你要注意： // prototype是函数才会有的属性 Person.prototype.name = 'Kevin'; var person1 = new Person(); var person2 = new Person(); console.log(person1.name) // Kevin console.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： proto 这是每一个JavaScript对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： function Person() { } var person = new Person(); console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor 指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor﻿，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： function Person() { } console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出： function Person() { } var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： function Person() { } Person.prototype.name = 'Kevin'; var person = new Person(); person.name = 'Daisy'; console.log(person.name) // Daisy delete person.name; console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型 在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： var obj = new Object(); obj.name = 'Kevin' console.log(obj.name) // Kevin 所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 proto 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链 那 Object.prototype 的原型呢？ null，不信我们可以打印： console.log(Object.prototype.__proto__ === null) // true 所以查到属性的时候查到 Object.prototype 就可以停止查找了。 所以最后一张关系图就是 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充 最后，补充三点大家可能不会注意的地方： constructor 首先是 constructor 属性，我们看个例子： function Person() { } var person = new Person(); console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： person.constructor === Person.prototype.constructor proto 其次是 proto ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.proto 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？ 最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 "},"javaScript/context.html":{"url":"javaScript/context.html","title":"执行上下文","keywords":"","body":"执行上下文 在《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript深入之变量对象》、《JavaScript深入之作用域链》、《JavaScript深入之从ECMAScript规范解读this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。 因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。 思考题 在《JavaScript深入之词法作用域和动态作用域》中，提出这样一道思考题： var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f(); } checkscope(); var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f; } checkscope()(); 两段代码都会打印'local scope'。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 紧接着就在下一篇《JavaScript深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。 具体执行分析 我们分析第一段代码： var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f(); } checkscope(); 执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 ECStack = [ globalContext ]; 2.全局上下文初始化 globalContext = { VO: [global, scope, checkscope], Scope: [globalContext.VO], this: globalContext.VO } 2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] checkscope.[[scope]] = [ globalContext.VO ]; 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 ECStack = [ checkscopeContext, globalContext ]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] checkscopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to function f(){} }, Scope: [AO, globalContext.VO], this: undefined } 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 ECStack = [ fContext, checkscopeContext, globalContext ]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链 用 arguments 创建活动对象 初始化活动对象，即加入形参、函数声明、变量声明 将活动对象压入 f 作用域链顶端 fContext = { AO: { arguments: { length: 0 } }, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined } 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 ECStack = [ checkscopeContext, globalContext ]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 ECStack = [ globalContext ]; 第二段代码就留给大家去尝试模拟它的执行过程。 var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f; } checkscope()(); 不过，在下一篇《JavaScript深入之闭包》中也会提及这段代码的执行过程。 "},"javaScript/youDontKnowJs.html":{"url":"javaScript/youDontKnowJs.html","title":"你不知道的js（上）","keywords":"","body":"你不知道的js（上） LHS与RHS LHS可以理解为某变量被赋值，RHS可以理解为被调用 举个栗子 function foo(a){ console.log(a); //2 } foo(2) foo进行RHS foo的形参相当于a=2 所以a进行LHS console是RHS console里的a是RHS 理解作用于 作用于嵌套 现在当前作用于找某变量，找不到时引擎会向外层嵌套的作用于中继续寻找，直到找到该变量，或抵达最外层的作用域（也就是全局作用于）为止。 注意一下代码 function foo (a){ console.log(a + b); //4 } var b = 2; foo(2); function foo (a){ console.log(a + b); //NaN } foo(2); var b = 2; function foo (a){ console.log(a + b); //NaN var b = 2 } foo(2); function foo (a){ console.log(a + b); //ReferenceError: b is not defined b = 2 } foo(2); "},"javaScript/Currying.html":{"url":"javaScript/Currying.html","title":"柯里化函数","keywords":"","body":"柯里化函数 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家哈斯凯尔·加里命名的，尽管它是 Moses Schönfinkel 和 Gottlob Frege 发明的。 这是来自维基百科的名词解释。顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。 看一下通用实现： function currying(fn) { var slice = Array.prototype.slice, __args = slice.call(arguments, 1); return function () { var __inargs = slice.call(arguments); return fn.apply(null, __args.concat(__inargs)); }; } 柯里化的实用性体现在很多方面： 1 提高适用性。 【通用函数】解决了兼容性问题，但同时也会再来，使用的不便利性，不同的应用场景往，要传递很多参数，以达到解决特定问题的目的。有时候应用中，同一种规则可能会反复使用，这就可能会造成代码的重复性。 看下面一个例子： function square(i) { return i * i; } function dubble(i) { return i *= 2; } function map(handeler, list) { return list.map(handeler); } // 数组的每一项平方 map(square, [1, 2, 3, 4, 5]); map(square, [6, 7, 8, 9, 10]); map(square, [10, 20, 30, 40, 50]); // ...... // 数组的每一项加倍 map(dubble, [1, 2, 3, 4, 5]); map(dubble, [6, 7, 8, 9, 10]); map(dubble, [10, 20, 30, 40, 50]); 例子中，创建了一个map通用函数，用于适应不同的应用场景。显然，通用性不用怀疑。同时，例子中重复传入了相同的处理函数：square和dubble。 应用中这种可能会更多。当然，通用性的增强必然带来适用性的减弱。但是，我们依然可以在中间找到一种平衡。 看下面，我们利用柯里化改造一下： function square(i) { return i * i; } function dubble(i) { return i *= 2; } function map(handeler, list) { return list.map(handeler); } var mapSQ = currying(map, square); mapSQ([1, 2, 3, 4, 5]); mapSQ([6, 7, 8, 9, 10]); mapSQ([10, 20, 30, 40, 50]); // ...... var mapDB = currying(map, dubble); mapDB([1, 2, 3, 4, 5]); mapDB([6, 7, 8, 9, 10]); mapDB([10, 20, 30, 40, 50]); // ...... 我们缩小了函数的适用范围，但同时提高函数的适性。当然，也有扩展函数适用范围的方法--反柯里化，留到下一篇再讨论。 由此，可知柯里化不仅仅是提高了代码的合理性，更重的它突出一种思想---降低适用范围，提高适用性。 下面再看一个例子，一个应用范围更广泛更熟悉的例子： function Ajax() { this.xhr = new XMLHttpRequest(); } Ajax.prototype.open = function(type, url, data, callback) { this.onload = function() { callback(this.xhr.responseText, this.xhr.status, this.xhr); } this.xhr.open(type, url, data.async); this.xhr.send(data.paras); } 'get post'.split(' ').forEach(function(mt) { Ajax.prototype[mt] = currying(Ajax.prototype.open, mt); }); var xhr = new Ajax(); xhr.get('/articles/list.php', {}, function(datas) { // done(datas) }); var xhr1 = new Ajax(); xhr1.post('/articles/add.php', {}, function(datas) { // done(datas) }); 2 延迟执行。 柯里化的另一个应用场景是延迟执行。不断的柯里化，累积传入的参数，最后执行。 看下面： var add = function() { var _this = this, _args = arguments return function() { if (!arguments.length) { var sum = 0; for (var i = 0, c; c = _args[i++];) sum += c return sum } else { Array.prototype.push.apply(_args, arguments) return arguments.callee } } } add(1)(2)(3)(4)();//10 通用的写法： var curry = function(fn) { var _args = [] return function cb() { if (arguments.length == 0) { return fn.apply(this, _args) } Array.prototype.push.apply(_args, arguments); return cb; } } 上面累加的例子，可以实验一下怎么写？ 3 固定易变因素。 柯里化特性决定了它这应用场景。提前把易变因素，传参固定下来，生成一个更明确的应用函数。最典型的代表应用，是bind函数用以固定this这个易变对象。 Function.prototype.bind = function(context) { var _this = this, _args = Array.prototype.slice.call(arguments, 1); return function() { return _this.apply(context, _args.concat(Array.prototype.slice.call(arguments))) } } "},"javaScript/ascension.html":{"url":"javaScript/ascension.html","title":"变量提升与函数提升","keywords":"","body":"变量提升与函数提升 在JavaScript中存在提升的情况，这种提升有两种提升分别是变量提升与函数提升，而且是函数会首先被提升，然后才是变量。 变量提升 看下面的例子： console.log( a ); //undefined。 var a = 2; 上面代码可以写成下面的形式 var a; console.log( a ); //undefined a=2; 再看下面的例子： var a=2; console.log(a); //2 上面的代码可以写成下面的形式： var a; a=2; console.log(a) //2 函数提升 看下面的例子： foo(); function foo() { console.log( a ); // undefined var a = 2; } 上面的例子可以转化成下面的形式 function foo() { console.log( a ); // undefined var a = 2; } foo(); 再看下面的例子： 函数声明会被提升，但是函数表达式却不会被提升 foo(); // TypeError bar(); // ReferenceError var foo = function bar() { ... }; 上面的代码可以转化下面的代码 var foo; foo(); // TypeError bar(); // ReferenceError foo = function() { var bar = foo; } 或者是转化成下面的代码 var foo; foo(); // TypeError bar(); // ReferenceError foo = function() { var bar = ...self...; } 再看下面的例子 foo(); // 3 function foo() { console.log( 1 ); } var foo = function() { console.log( 2 ); }; function foo() { console.log( 3 ); } foo(); //2 上面的代码可以转化下面的代码 var foo; function foo() { console.log( 1 ); } function foo() { console.log( 3 ); } foo(); // 3 var foo = function() { console.log( 2 ); }; foo(); //2 非常有意思的现象 "},"javaScript/webSocket.html":{"url":"javaScript/webSocket.html","title":"webSocket","keywords":"","body":"webSocket 目录结构如下 WebSocketTestChat.java里的代码: package com.moven.websockets; import java.io.IOException; import java.util.Set; import javax.servlet.http.HttpSession; import javax.websocket.OnClose; import javax.websocket.OnError; import javax.websocket.OnMessage; import javax.websocket.OnOpen; import javax.websocket.Session; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; @ServerEndpoint(\"/chat/{username}\") public class WebSocketTestChat { Set session_list = null; @OnMessage public void onMessage(String message, Session session) { try{ session_list = session.getOpenSessions(); HttpSession httpSession = null; String username = \"\"; if(session instanceof HttpSession){ httpSession = (HttpSession)session; Object param = httpSession.getAttribute(\"username\"); if(null != param){ username = param.toString(); } } else { username = session.getId(); } for (Session s : session_list) { s.getBasicRemote().sendText(\"当前总人数[\" + session_list.size() + \"]---\" + username + \"说:\" + message); } } catch(IOException e){ System.out.println(\"Client error\"); } } @OnError public void onError(Throwable t) throws Throwable { System.out.println(\"Client error = \"+t.getMessage()); } @OnOpen public void onOpen(@PathParam(\"username\") String username, Session session) { HttpSession httpSession = null; if(session instanceof HttpSession){ httpSession = (HttpSession)session; httpSession.setAttribute(\"username\", username); } System.out.println(\"Client connected\"); } @OnClose public void onClose() { System.out.println(\"Connection closed\"); } } chat.html里边的代码 Testing websockets var webSocket = new WebSocket( 'ws://local.moven.cn:8081/moven_im/chat/msw/lyh'); webSocket.onerror = function(event) { onError(event) }; webSocket.onopen = function(event) { onOpen(event) }; webSocket.onmessage = function(event) { onMessage(event) }; function onMessage(event) { document.getElementById('messages').innerHTML += '' + event.data; } function onOpen(event) { document.getElementById('messages').innerHTML = 'Connection established'; } function onError(event) { alert(event.data); } function start() { var text = document.getElementById('text').value; if(text){ webSocket.send(text); } else { alert(\"Message can't be null\"); } document.getElementById('text').value = ''; return false; } web.xml里边的代码 Simple web application pom.xml里边的代码 4.0.0 com.moven moven_im 1.0-SNAPSHOT war UTF-8 org.apache.maven.plugins maven-compiler-plugin 1.7 1.7 javax javaee-api 7.0 provided "},"javaScript/error.html":{"url":"javaScript/error.html","title":"javaScript各种错误类型","keywords":"","body":"javaScript各种错误类型 1.SyntaxError（语法错误） 解析代码时发生的语法错误 eg:var 1a; 　　Uncaught SyntaxError: Unexpected number 2.ReferenceError（引用错误） a.引用了一个不存在的变量 eg: console.log(a); 　　Uncaught ReferenceError: a is not defined b.将变量赋值给一个无法被赋值的对象 eg:console.log()= 1; 　　Uncaught ReferenceError: Invalid left-hand side in assignment 3.RangeError（范围错误） 超出有效范围 eg:var a= new Array(-1); 　　Uncaught RangeError: Invalid array length 4.TypeError（类型错误） a.变量或参数不是预期类型，比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 eg: var a= new 123; 　　Uncaught TypeError: 123 is not a function b.调用对象不存在的方法 eg:var a;a.aa(); 　　Uncaught TypeError: Cannot read property 'aa' of undefined 5.URLError（URL错误） 与url相关函数参数不正确，主要是encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 eg: decodeURI('%2') 　　Uncaught URIError: URI malformed 6.EvalError（eval错误） eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再在ES5中出现了，只是为了保证与以前代码兼容，才继续保留。 以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，人为生成错误对象的实例。 new Error(\"出错了！\"); new RangeError(\"出错了，变量超出有效范围！\"); new TypeError(\"出错了，变量类型无效！\"); 上面代码表示新建错误对象的实例，实质就是手动抛出错误。可以看到，错误对象的构造函数接受一个参数，代表错误提示信息（message）。 "},"javaScript/this.html":{"url":"javaScript/this.html","title":"javaScript的this","keywords":"","body":"javaScript的this this的常见绑定形式 1.默认绑定 2.隐式绑定 3.显示绑定 4.new绑定 在弄清楚这些绑定之前来弄清楚几个概念调用栈和调用位置 下面我们来看看到底什么是调用栈和调用位置: function baz() { // 当前调用栈是:baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // bar // 因此，当前调用位置在 baz 中 console.log( \"bar\" ); foo(); // bar -> foo // 因此，当前调用位置在 bar 中 console.log( \"foo\" ); } baz(); // 上面的代码让我们初步明白了调用栈，和调用位置 默认绑定(指绑定全局变量) 思考下面的代码 function foo() { console.log( this.a ); } var a = 2; foo(); // 2 上面函数的当前当前调用位置是全局作用域，所以this默认绑定的是window 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined: function foo() { \"use strict\"; console.log( this.a ); } var a = 2; foo(); // TypeError: this is undefined 隐式绑定 在一些复杂的结构中我们经常会碰到隐式绑定 先来看下面的代码： function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 foo函数绑定在了obj下边的foo属性上边，所以他的当前调用位置在obj中所以this指向obj。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置 function foo() { console.log( this.a ); } var obj2 = { a: 42, foo: foo }; var obj1 = { a: 2, obj2: obj2 }; obj1.obj2.foo(); // 42 隐式丢失 看下面的例子： function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; var bar = obj.foo; // 函数别名! var a = \"oops, global\"; // a 是全局对象的属性 bar(); // \"oops, global\" 是不是结果让人诧异 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。（这是你不知道的JavaScript上中的解释，但是我感觉没有说服力，后面会查明真象） 以形参传入其实就是隐式赋值 function foo() { console.log( this.a ); } function doFoo(fn) { // fn 其实引用的是 foo fn(); // 如果把函数传入语言内置的函数而不是传入你自己声明的函数，也会隐式赋值 function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; var a = \"oops, global\"; // a 是全局对象的属性 setTimeout( obj.foo, 100 ); // \"oops, global\" 通过上面的代码可以看出来不做显示绑定还是比较危险的而且隐式绑定还是很危险的 显式绑定 硬绑定（常用的是call，apply，bind）三种方式的使用 call function foo() { console.log( this.a ); } var obj = { a:2 }; var bar = function() { foo.call( obj ); }; bar(); // 2 setTimeout( bar, 100 ); // 2 // 硬绑定的 bar 不可能再修改它的 this bar.call( window ); // 2 apply function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a:2 }; var bar = function() { return foo.apply( obj, arguments ); }; var b = bar( 3 ); // 2 3 console.log( b ); // 5 另一种使用方法是创建一个 i 可以重复使用的辅助函数: function foo(something) { console.log( this.a, something ); return this.a + something; } // 简单的辅助绑定函数 function bind(fn, obj) { return function() { return fn.apply( obj, arguments ); }; } var obj = { a:2 }; var bar = bind( foo, obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 bind 在ES5中内置了bind方法 function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a:2 }; var bar = foo.bind( obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 这里说明一下bind返回的是方法名要想运行样加();比如foo.bind( obj )();这才是运行状态； (bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数)你不知道的JavaScript中的解释 API调用的“上下文” function foo(el) { console.log( el, this.id ); } var obj = { id: \"awesome\" }; // 调用 foo(..) 时把 this 绑定到 obj [1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome 有没有一丝懵逼，看解释 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一 个可选的参数，通常被称为“上下文”(context)，其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些 代码。 new绑定 在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建(或者说构造)一个全新的对象。 这个新对象会被执行[[原型]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 思考下面的代码:function foo(a) { this.a = a; } var bar = new foo(2); console.log( bar.a ); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。 "},"React/":{"url":"React/","title":"React","keywords":"","body":"React "},"React/webpack.html":{"url":"React/webpack.html","title":"webpack项目搭建","keywords":"","body":"webpack项目搭建 什么是 webpack？ webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。 我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。 你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 React-Boostrap 和 Redux。 webpack的官网是 http://webpack.github.io/ ，文档地址是 http://webpack.github.io/docs/ ，想对其进行更详细了解的可以点进去瞧一瞧。 webpack 的优势 其优势主要可以归类为如下几个： webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 能被模块化的不仅仅是 JS 了。 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。 扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。 我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调： define(['package/lib'], function(lib){ function foo(){ lib.log('hello world!'); } return { foo: foo }; }); 另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写： define(function (require, exports, module){ var someModule = require(\"someModule\"); var anotherModule = require(\"anotherModule\"); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function (){ someModule.doTehAwesome(); anotherModule.doMoarAwesome(); }; }); 然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）： var someModule = require(\"someModule\"); var anotherModule = require(\"anotherModule\"); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function (){ someModule.doTehAwesome(); anotherModule.doMoarAwesome(); }; 这样撸码自然更简单，跟回调神马的说 byebye~ 不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。 安装和配置 一. 安装 我们常规直接使用 npm 的形式来安装： $ npm install webpack -g 当然如果常规项目还是把依赖写入 package.json 包去更人性化： $ npm init $ npm install webpack --save-dev 二. 配置 每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。 我们看看下方的示例： var webpack = require('webpack'); var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js'); module.exports = { //插件项 plugins: [commonsPlugin], //页面入口文件配置 entry: { index : './src/js/page/index.js' }, //入口文件输出配置 output: { path: 'dist/js/page', filename: '[name].js' }, module: { //加载器配置 loaders: [ { test: /\\.css$/, loader: 'style-loader!css-loader' }, { test: /\\.js$/, loader: 'jsx-loader?harmony' }, { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'}, { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'} ] }, //其它解决方案配置 resolve: { root: 'E:/github/flux-example/src', //绝对路径 extensions: ['', '.js', '.json', '.scss'], alias: { AppStore : 'js/stores/AppStores.js', ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' } } }; ⑴ plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。 ⑵ entry 是页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里），其语法大致为： { entry: { page1: \"./page1\", //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出 page2: [\"./entry1\", \"./entry2\"] }, output: { path: \"dist/js/page\", filename: \"[name].bundle.js\" } } 该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。 ⑶ module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理： module: { //加载器配置 loaders: [ //.css 文件使用 style-loader 和 css-loader 来处理 { test: /\\.css$/, loader: 'style-loader!css-loader' }, //.js 文件使用 jsx-loader 来编译处理 { test: /\\.js$/, loader: 'jsx-loader?harmony' }, //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理 { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'}, //图片文件使用 url-loader 来处理，小于8kb的直接转为base64 { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'} ] } 如上，\"-loader\"其实是可以省略不写的，多个loader之间用“!”连接起来。 注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。 拿最后一个 url-loader 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装： npm install url-loader -save-dev 配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）。 ⑷ 最后是 resolve 配置，这块很好理解，直接写注释了： resolve: { //查找module的话从这里开始查找 root: 'E:/github/flux-example/src', //绝对路径 //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: ['', '.js', '.json', '.scss'], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: { AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可 ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' } } 关于 webpack.config.js 更详尽的配置可以参考这里。 运行 webpack webpack 的执行也很简单，直接执行 $ webpack --display-error-details 即可，后面的参数“--display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。 其他主要的参数有： $ webpack --config XXX.js //使用另一份配置文件（比如webpack.config2.js）来打包 $ webpack --watch //监听变动并自动打包 $ webpack -p //压缩混淆脚本，这个非常非常重要！ $ webpack -d //生成map映射文件，告知哪些模块被最终打包到哪里了 其中的 -p 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）。 模块引入 上面唠嗑了那么多配置和执行方法，下面开始说说寻常页面和脚本怎么使用呗。 一. HTML 直接在页面引入 webpack 最终生成的页面脚本即可，不用再写什么 data-main 或 seajs.use 了： demo 可以看到我们连样式都不用引入，毕竟脚本执行时会动态生成并标签打到head里。 二. JS 各脚本模块可以直接使用 commonJS 来书写，并可以直接引入未经编译的模块，比如 JSX、sass、coffee等（只要你在 webpack.config.js 里配置好了对应的加载器）。 我们再看看编译前的页面入口文件（index.js）： require('../../css/reset.scss'); //加载初始化样式 require('../../css/allComponent.scss'); //加载组件样式 var React = require('react'); var AppWrap = require('../component/AppWrap'); //加载组件 var createRedux = require('redux').createRedux; var Provider = require('redux/react').Provider; var stores = require('AppStore'); var redux = createRedux(stores); var App = React.createClass({ render: function() { return ( {function() { return ; }} ); } }); React.render( , document.body ); 一切就是这么简单么么哒~ 后续各种有的没的，webpack 都会帮你进行处理。 其他 至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。 一. shimming 在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 exports-loader 来帮忙： { test: require.resolve(\"./src/js/tool/swipe.js\"), loader: \"exports?swipe\"} 之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了： require('./tool/swipe.js'); swipe(); 二. 自定义公共模块提取 在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。 但有时候我们希望能更加个性化一些，我们可以这样配置： var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\"); module.exports = { entry: { p1: \"./page1\", p2: \"./page2\", p3: \"./page3\", ap1: \"./admin/page1\", ap2: \"./admin/page2\" }, output: { filename: \"[name].js\" }, plugins: [ new CommonsChunkPlugin(\"admin-commons.js\", [\"ap1\", \"ap2\"]), new CommonsChunkPlugin(\"commons.js\", [\"p1\", \"p2\", \"admin-commons.js\"]) ] }; // s required: // page1.html: commons.js, p1.js // page2.html: commons.js, p2.js // page3.html: p3.js // admin-page1.html: commons.js, admin-commons.js, ap1.js // admin-page2.html: commons.js, admin-commons.js, ap2.js 三. 独立打包样式文件 有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以标签引入。这时候我们需要 extract-text-webpack-plugin 来帮忙： var webpack = require('webpack'); var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js'); var ExtractTextPlugin = require(\"extract-text-webpack-plugin\"); module.exports = { plugins: [commonsPlugin, new ExtractTextPlugin(\"[name].css\")], entry: { //...省略其它配置 } } 最终 webpack 执行后会乖乖地把样式文件提取出来： 四. 使用CDN/远程文件 有时候我们希望某些模块走CDN并以的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。 这时候我们可以在配置文件里使用 externals 属性来帮忙： { externals: { // require(\"jquery\") 是引用自外部模块的 // 对应全局变量 jQuery \"jquery\": \"jQuery\" } } 需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。 我们倒也可以使用 script.js 在脚本中来加载我们的模块： var $script = require(\"scriptjs\"); $script(\"//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js\", function() { $('body').html('It works!') }); 五. 与 grunt/gulp 配合 以 gulp 为示例，我们可以这样混搭： gulp.task(\"webpack\", function(callback) { // run webpack webpack({ // configuration }, function(err, stats) { if(err) throw new gutil.PluginError(\"webpack\", err); gutil.log(\"[webpack]\", stats.toString({ // output options })); callback(); }); }); 当然我们只需要把配置写到 webpack({ ... }) 中去即可，无须再写 webpack.config.js 了。 更多参照信息请参阅：grunt配置 / gulp配置 。 六. React 相关 ⑴ 推荐使用 npm install react 的形式来安装并引用 React 模块，而不是直接使用编译后的 react.js，这样最终编译出来的 React 部分的脚本会减少 10-20 kb左右的大小。 ⑵ react-hot-loader 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 webpack-dev-server 使用更佳！ "},"React/react.html":{"url":"React/react.html","title":"React项目的搭建","keywords":"","body":"react项目搭建 要想使用npm,请先安装nodejs. 第一步、安装全局包 $ npm install babel -g $ npm install webpack -g $ npm install webpack-dev-server -g 第二步、创建根目录 创建一个根目录，目录名为：reactApp，再使用 npm init 初始化，生成 package.json 文件： $ mkdir reactApp $ cd reactApp/ $ npm init 命令行显示以下内容 name: (reactApp) runoob-react-test version: (1.0.0) description: cllgeek entry point: (index.js) test command: git repository: keywords: author: license: (ISC) About to write to /Users/tianqixin/www/reactApp/package.json: { \"name\": \"react-runoob\", \"version\": \"1.0.0\", \"description\": \"cllgeek test\", \"main\": \"index.js\", \"scripts\": { \"start\": \"webpack-dev-server --hot\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"react\": \"^0.14.8\", \"react-dom\": \"^0.14.8\" } } Is this ok? (yes) 第三步、添加越来包及插件 因为我们要使用 React, 所以我们需要先安装它，–save 命令用于将包添加至 package.json 文件。 $ npm install react --save $ npm install react-dom --save 同时我们也要安装一些 babel 插件 $ npm install babel-core $ npm install babel-loader $ npm install babel-preset-react $ npm install babel-preset-es2015 第四步、创建文件 接下来我们创建一些必要文件： $ touch index.html $ touch App.jsx $ touch main.js $ touch webpack.config.js 第五步、设置编译器，服务器，载入器 打开 webpack.config.js 文件添加以下代码: var config = { entry: './main.js', output: { path:'./', filename: 'index.js', }, devServer: { inline: true, port: 8888 }, module: { loaders: [ { test: /.jsx?$/, exclude: /node_modules/, loader: 'babel', query: { presets: ['es2015', 'react'] } }] } } module.exports = config; entry: 指定打包的入口文件 main.js。 output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称。 devServer：设置服务器端口号为 8888，端口后你可以自己设定 。 module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。 现在打开 package.json 文件，找到 “scripts” 中的 “test” “echo \\”Error: no test specified\\” && exit 1″ 使用以下代码替换： \"start\": \"webpack-dev-server --hot\" 替换后的 package.json 文件 内容如下： $ cat package.json { \"name\": \"runoob-react-test\", \"version\": \"1.0.0\", \"description\": \"cllgeek test\", \"main\": \"index.js\", \"scripts\": { \"start\": \"webpack-dev-server --hot\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"react\": \"^0.14.7\", \"react-dom\": \"^0.14.7\" } } 现在我们可以使用 npm start 命令来启动服务。–hot 命令会在文件变化后重新载入，这样我们就不需要在代码修改后重新刷新浏览器就能看到变化。 第六步、index.html 设置 div id = “app” 为我们应用的根元素，并引入 index.js 脚本文件。 React App - cllgeek(cllgeek.com) 第七步、App.jsx 和 main.js 这是第一个 react 组件。后面的章节我们会详细介绍 React 组件。这个组件将输出 Hello World!!!。 App.jsx 文件代码 import React from 'react'; class App extends React.Component { render() { return ( Hello World!!! ); } } export default App; 我们需要引入组件并将其渲染到根元素 App 上，这样我们才可以在浏览器上看到它。 main.js 文件代码 import React from 'react'; import ReactDOM from 'react-dom'; import App from './App.jsx'; ReactDOM.render(, document.getElementById('app')) 注意： 如果想要组件可以在任何的应用中使用，需要在创建后使用 export 将其导出，在使用组件的文件使用 import将其导入。 第八步、运行服务 完成以上配置后，我们即可运行该服务： $ npm start 通过浏览器访问 http://localhost:7777/，输出结果如下: "},"React/router.html":{"url":"React/router.html","title":"React-Router使用入门","keywords":"","body":"React Router使用教程 一、基本用法 React Router 安装命令如下。 $ npm install -S react-router 使用时，路由器 Router 就是React的一个组件。 import { Router } from 'react-router'; render(, document.getElementById('app')); Router 组件本身只是一个容器，真正的路由要通过 Route 组件定义。 import { Router, Route, hashHistory } from 'react-router'; render(( ), document.getElementById('app')); 上面代码中，用户访问根路由 / （比如 http://www.example.com/ ），组件 APP 就会加载到 document.getElementById('app') 。 你可能还注意到， Router 组件有一个参数 history ，它的值 hashHistory 表示，路由的切换由URL的hash变化决定，即URL的 # 部分发生变化。举例来说，用户访问 http://www.example.com/ ，实际会看到的是 http://www.example.com/#/ 。 Route 组件定义了URL路径与组件的对应关系。你可以同时使用多个 Route 组件。 上面代码中，用户访问 /repos （比如 http://localhost:8080/#/repos ）时，加载 Repos 组件；访问 /about （ http://localhost:8080/#/about ）时，加载 About 组件。 二、嵌套路由 Route 组件还可以嵌套。 上面代码中，用户访问 /repos 时，会先加载 App 组件，然后在它的内部再加载 Repos 组件。 App 组件要写成下面的样子。 export default React.createClass({ render() { return {this.props.children} } }) 上面代码中， App 组件的 this.props.children 属性就是子组件。 子路由也可以不写在 Router 组件里面，单独传入 Router 组件的 routes 属性。 let routes = ; 三、 path 属性 Route 组件的 path 属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。 请看下面的例子。 上面代码中，当用户访问 /inbox/messages/:id 时，会加载下面的组件。 如果省略外层 Route 的 path 参数，写成下面的样子。 现在用户访问 /inbox/messages/:id 时，组件加载还是原来的样子。 四、通配符 path 属性可以使用通配符。 // 匹配 /hello/michael // 匹配 /hello/ryan // 匹配 /hello // 匹配 /hello/michael // 匹配 /hello/ryan // 匹配 /files/hello.jpg // 匹配 /files/hello.html // 匹配 /files/ // 匹配 /files/a // 匹配 /files/a/b // 匹配 /files/hello.jpg // 匹配 /files/path/to/file.jpg 通配符的规则如下。 （1） :paramName :paramName 匹配URL的一个部分，直到遇到下一个 / 、 ? 、 # 为止。这个路径参数可以通过 this.props.params.paramName 取出。 （2） () () 表示URL的这个部分是可选的。 （3） * * 匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。 （4） ** ** 匹配任意字符，直到下一个 / 、 ? 、 # 为止。匹配方式是贪婪模式。 path 属性也可以使用相对路径（不以 / 开头），匹配时就会相对于父组件的路径，可以参考上一节的例子。嵌套路由如果想摆脱这个规则，可以使用绝对路由。 路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。 上面代码中，路径 /comments 同时匹配两个规则，第二个规则不会生效。 设置路径参数时，需要特别小心这一点。 上面代码中，用户访问 /about/me 时，不会触发第二个路由规则，因为它会匹配 /:userName/:id 这个规则。因此，带参数的路径一般要写在路由规则的底部。 此外，URL的查询字符串 /foo?bar=baz ，可以用 this.props.location.query.bar 获取。 五、IndexRoute 组件 下面的例子，你会不会觉得有一点问题？ 上面代码中，访问根路径 / ，不会加载任何子组件。也就是说， App 组件的 this.props.children ，这时是 undefined 。 因此，通常会采用 {this.props.children || } 这样的写法。这时， Home 明明是 Accounts 和 Statements 的同级组件，却没有写在 Route 中。 IndexRoute 就是解决这个问题，显式指定 Home 是根路由的子组件，即指定默认情况下加载的子组件。你可以把 IndexRoute 想象成某个路径的 index.html 。 现在，用户访问 / 的时候，加载的组件结构如下。 这种组件结构就很清晰了： App 只包含下级组件的共有元素，本身的展示内容则由 Home 组件定义。这样有利于代码分离，也有利于使用React Router提供的各种API。 注意， IndexRoute 组件没有路径参数 path 。 六、Redirect 组件 组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。 {/* 从 /inbox/messages/:id 跳转到 /messages/:id */} 现在访问 /inbox/messages/5 ，会自动跳转到 /messages/5 。 七、IndexRedirect 组件 IndexRedirect 组件用于访问根路由的时候，将用户重定向到某个子组件。 上面代码中，用户访问根路径时，将自动重定向到子组件 welcome 。 八、Link Link 组件用于取代 a标签，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是 a标签的React 版本，可以接收 Router 的状态。 render() { return About Repos } 如果希望当前的路由与其他路由有不同样式，这时可以使用 Link 组件的 activeStyle 属性。 About Repos 上面代码中，当前页面的链接会红色显示。 另一种做法是，使用 activeClassName 指定当前路由的 Class 。 About Repos 上面代码中，当前页面的链接的 class 会包含 active 。 在 Router 组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写。 import { browserHistory } from 'react-router'; browserHistory.push('/some/path'); 九、IndexLink 如果链接到根路由 / ，不要使用 Link 组件，而要使用 IndexLink 组件。 这是因为对于根路由来说， activeStyle 和 activeClassName 会失效，或者说总是生效，因为 / 会匹配任何子路由。而 IndexLink 组件会使用路径的精确匹配。 Home 上面代码中，根路由只会在精确匹配时，才具有 activeClassName 。 另一种方法是使用 Link 组件的 onlyActiveOnIndex 属性，也能达到同样效果。 Home 实际上， IndexLink 就是对 Link 组件的 onlyActiveOnIndex 属性的包装。 十、histroy 属性 Router 组件的 history 属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。 history 属性，一共可以设置三种值。 browserHistory hashHistory createMemoryHistory 如果设为 hashHistory ，路由将通过URL的hash部分（ # ）切换，URL的形式类似 example.com/#/some/path 。 import { hashHistory } from 'react-router' render( , document.getElementById('app') ) 如果设为 browserHistory ，浏览器的路由就不再通过 Hash 完成了，而显示正常的路径 example.com/some/path ，背后调用的是浏览器的History API。 import { browserHistory } from 'react-router' render( , document.getElementById('app') ) 但是，这种情况需要对 服务器改造 。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。 如果开发服务器使用的是 webpack-dev-server ，加上 --history-api-fallback 参数就可以了。 $ webpack-dev-server --inline --content-base . --history-api-fallback createMemoryHistory 主要用于服务器渲染。它创建一个内存中的 history 对象，不与浏览器URL互动。 const history = createMemoryHistory(location) 十一、表单处理 Link 组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？ 下面是一个表单。 Go 第一种方法是使用 browserHistory.push import { browserHistory } from 'react-router' // ... handleSubmit(event) { event.preventDefault() const userName = event.target.elements[0].value const repo = event.target.elements[1].value const path = `/repos/${userName}/${repo}` browserHistory.push(path) }, 第二种方法是使用 context 对象。 export default React.createClass({ // ask for `router` from context contextTypes: { router: React.PropTypes.object }, handleSubmit(event) { // ... this.context.router.push(path) }, }) 十二、路由的钩子 每个路由都有 Enter 和 Leave 钩子，用户进入或离开该路由时触发。 上面的代码中，如果用户离开 /messages/:id ，进入 /about 时，会依次触发以下的钩子。 /messages/:id 的 onLeave /inbox 的 onLeave /about 的 onEnter 下面是一个例子，使用 onEnter 钩子替代 组件。 replace(`/messages/${params.id}`) } /> 下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。 const Home = withRouter( React.createClass({ componentDidMount() { this.props.router.setRouteLeaveHook( this.props.route, this.routerWillLeave ) }, routerWillLeave(nextLocation) { // 返回 false 会继续停留当前页面， // 否则，返回一个字符串，会显示给用户，让其自己决定 if (!this.state.isSaved) return '确认要离开？'; }, }) ) 上面代码中， setRouteLeaveHook 方法为 Leave 钩子指定 routerWillLeave 函数。该方法如果返回 false ，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。 "},"React/redux.html":{"url":"React/redux.html","title":"Redux使用入门","keywords":"","body":"Redux使用入门 参考网站 1. 前言 随着WEB应用变得越来越复杂，再加上node前后端分离越来越流行，那么对数据流动的控制就显得越发重要。redux是在flux的基础上产生的，基本思想是保证数据的单向流动，同时便于控制、使用、测试。 redux不依赖于任意框架(库)，只要subscribe相应框架(库)的内部方法，就可以使用该应用框架保证数据流动的一致性。 那么如何使用redux呢？下面一步步进行解析，并带有源码说明，不仅做到 知其然 ，还要做到 知其所以然 。 2. 主干逻辑介绍(createStore) 2.1 简单demo入门 先来一个直观的认识： // 首先定义一个改变数据的plain函数，成为reducer function count (state, action) { var defaultState = { year: 2015, }; state = state || defaultState; switch (action.type) { case 'add': return { year: state.year + 1 }; case 'sub': return { year: state.year - 1 } default : return state; } } // store的创建 var createStore = require('redux').createStore; var store = createStore(count); // store里面的数据发生改变时，触发的回调函数 store.subscribe(function () { console.log('the year is: ', store.getState().year); }); // action: 触发state改变的唯一方法(按照redux的设计思路) var action1 = { type: 'add' }; var action2 = { type: 'add' }; var action3 = { type: 'sub' }; // 改变store里面的方法 store.dispatch(action1); // 'the year is: 2016 store.dispatch(action2); // 'the year is: 2017 store.dispatch(action3); // 'the year is: 2016 2.2 挖掘createStore实现 为了说明主要问题，仅列出其中的关键代码，全部代码，可以点击 这里 阅读。 a首先看createStore到底都返回的内容: export default function createStore(reducer, initialState) { ... return { dispatch, subscribe, getState, replaceReducer } } 每个属性的含义是: - dispatch: 用于action的分发，改变store里面的state - subscribe: 注册listener，store里面state发生改变后，执行该listener - getState: 读取store里面的state - replaceReducer: 替换reducer，改变state修改的逻辑 b关键代码解析 export default function createStore(reducer, initialState) { // 这些都是闭包变量 var currentReducer = reducer var currentState = initialState var listeners = [] var isDispatching = false; // 返回当前的state function getState() { return currentState } // 注册listener，同时返回一个取消事件注册的方法 function subscribe(listener) { listeners.push(listener) var isSubscribed = true return function unsubscribe() { if (!isSubscribed) { return } isSubscribed = false var index = listeners.indexOf(listener) listeners.splice(index, 1) } } // 通过action该改变state，然后执行subscribe注册的方法 function dispatch(action) { try { isDispatching = true currentState = currentReducer(currentState, action) } finally { isDispatching = false } listeners.slice().forEach(listener => listener()) return action } // 替换reducer，修改state变化的逻辑 function replaceReducer(nextReducer) { currentReducer = nextReducer dispatch({ type: ActionTypes.INIT }) } // 初始化时，执行内部一个dispatch，得到初始state dispatch({ type: ActionTypes.INIT }) } 如果还按照2.1的方式进行开发，那跟flux没有什么大的区别，需要手动解决很多问题，那redux如何将整个流程模板化(Boilerplate)呢? 3. 保证store的唯一性 随着应用越来越大，一方面，不能把所有的数据都放到一个reducer里面，另一方面，为每个reducer创建一个store，后续store的维护就显得比较麻烦。如何将二者统一起来呢？ 3.1 demo入手 通过combineReducers将多个reducer合并成一个rootReducer: // 创建两个reducer: count year function count (state, action) { state = state || {count: 1} switch (action.type) { default: return state; } } function year (state, action) { state = state || {year: 2015} switch (action.type) { default: return state; } } // 将多个reducer合并成一个 var combineReducers = require('./').combineReducers; var rootReducer = combineReducers({ count: count, year: year, }); // 创建store，跟2.1没有任何区别 var createStore = require('./').createStore; var store = createStore(rootReducer); var util = require('util'); console.log(util.inspect(store)); //输出的结果，跟2.1的store在结构上不存在区别 // { dispatch: [Function: dispatch], // subscribe: [Function: subscribe], // getState: [Function: getState], // replaceReducer: [Function: replaceReducer] // } 3.2 源码解析combineReducers // 高阶函数，最后返回一个reducer export default function combineReducers(reducers) { // 提出不合法的reducers, finalReducers就是一个闭包变量 var finalReducers = pick(reducers, (val) => typeof val === 'function') // 将各个reducer的初始state均设置为undefined var defaultState = mapValues(finalReducers, () => undefined) // 一个总reducer，内部包含子reducer return function combination(state = defaultState, action) { var finalState = mapValues(finalReducers, (reducer, key) => { var previousStateForKey = state[key] var nextStateForKey = reducer(previousStateForKey, action) hasChanged = hasChanged || nextStateForKey !== previousStateForKey return nextStateForKey ); return hasChanged ? finalState : state } } 4. 自动实现dispatch 4.1 demo介绍 在2.1中，要执行state的改变，需要手动dispatch: var action = { type: '', payload: ''}; dispatch(action); 手动dispatch就显得啰嗦了，那么如何自动完成呢? var bindActionCreators = require('redux').bindActionCreators; // 可以在具体的应用框架隐式进行该过程(例如react-redux的connect组件中) bindActionCreators(action) 4.2 源码解析 // 隐式实现dispatch function bindActionCreator(actionCreator, dispatch) { return (...args) => dispatch(actionCreator(...args)) } export default function bindActionCreators(actionCreators, dispatch) { if (typeof actionCreators === 'function') { return bindActionCreator(actionCreators, dispatch) } return mapValues(actionCreators, actionCreator => bindAQctionCreator(actionCreator, dispatch) ) } 5. 支持插件 - 对dispatch的改造 5.1 插件使用demo 一个action可以是同步的，也可能是异步的，这是两种不同的情况， dispatch执行的时机是不一样的: // 同步的action creator, store可以默认实现dispatch function add() { return { tyle: 'add' } } dispatch(add()); // 异步的action creator，因为异步完成的时间不确定，只能手工dispatch function fetchDataAsync() { return function (dispatch) { requst(url).end(function (err, res) { if (err) return dispatch({ type: 'SET_ERR', payload: err}); if (res.status === 'success') { dispatch({ type: 'FETCH_SUCCESS', payload: res.data }); } }) } } 下面的问题就变成了，如何根据实际情况实现不同的dispatch方法，也即是根据需要实现不同的moddleware: // 普通的dispatch创建方法 var store = createStore(reducer, initialState); console.log(store.dispatch); // 定制化的dispatch var applyMiddleware = require('redux').applyMiddleware; // 实现action异步的middleware var thunk = requre('redux-thunk'); var store = applyMiddleware([thunk])(createStore); // 经过处理的dispatch方法 console.log(store.dispatch); 5.2 源码解析 // next: 其实就是createStore export default function applyMiddleware(...middlewares) { return (next) => (reducer, initialState) => { var store = next(reducer, initialState) var dispatch = store.dispatch var chain = [] var middlewareAPI = { getState: store.getState, dispatch: (action) => dispatch(action) } chain = middlewares.map(middleware => middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return { ...store, dispatch // 实现新的dispatch方法 } } } // 再看看redux-thunk的实现, next就是store里面的上一个dispatch function thunkMiddleware({ dispatch, getState }) { return function(next) { return function(action) { typeof action === 'function' ? action(dispatch, getState) : next(action); } } return next => action => typeof action === 'function' ? action(dispatch, getState) : next(action); } 6. 与react框架的结合 6.1 基本使用 目前已经有现成的工具 react-redux 来实现二者的结合: var rootReducers = combineReducers(reducers); var store = createStore(rootReducers); var Provider = require('react-redux').Provider; // App 为上层的Component class App extend React.Component{ render() { return ( ); } } // Container作用: 1. 获取store中的数据; 2.将dispatch与actionCreator结合起来 var connect = require('react-redux').connect; var actionCreators = require('...'); // MyComponent是与redux无关的组件 var MyComponent = require('...'); function select(state) { return { count: state.count } } export default connect(select, actionCreators)(MyComponent) 6.2 Provider – 提供store React通过Context属性，可以将属性(props)直接给子孙component，无须通过props层层传递, Provider仅仅起到获得store，然后将其传递给子孙元素而已: export default class Provider extends Component { getChildContext() { // getChildContext: 将store传递给子孙component return { store: this.store } } constructor(props, context) { super(props, context) this.store = props.store } componentWillReceiveProps(nextProps) { const { store } = this const { store: nextStore } = nextProps if (store !== nextStore) { warnAboutReceivingStore() } } render() { let { children } = this.props return Children.only(children) } } 6.3 connect – 获得store及dispatch(actionCreator) connect是一个高阶函数，首先传入mapStateToProps、mapDispatchToProps，然后返回一个生产 Component 的函数(wrapWithConnect)，然后再将真正的Component作为参数传入wrapWithConnect(MyComponent)，这样就生产出一个经过包裹的Connect组件，该组件具有如下特点: 通过this.context获取祖先Component的store props包括stateProps、dispatchProps、parentProps,合并在一起得到 nextState ，作为props传给真正的Component componentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互 shouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextState componentWillUnmount时移除注册的事件this.handleChange 在非生产环境下，带有热重载功能 主要的代码逻辑: export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) { return function wrapWithConnect(WrappedComponent) { class Connect extends Component { constructor(props, context) { // 从祖先Component处获得store this.store = props.store || context.store this.stateProps = computeStateProps(this.store, props) this.dispatchProps = computeDispatchProps(this.store, props) this.state = { storeState: null } // 对stateProps、dispatchProps、parentProps进行合并 this.updateState() } shouldComponentUpdate(nextProps, nextState) { // 进行判断，当数据发生改变时，Component重新渲染 if (propsChanged || mapStateProducedChange || dispatchPropsChanged) { this.updateState(nextProps) return true } } componentDidMount() { // 改变Component的state this.store.subscribe(() = { this.setState({ storeState: this.store.getState() }) }) } render() { // 生成包裹组件Connect return ( ) } } Connect.contextTypes = { store: storeShape } return Connect; } } 7. redux与react-redux关系图 "},"React/mobx.html":{"url":"React/mobx.html","title":"Mobx使用入门","keywords":"","body":"MobX入坑 MobX 是一个简单、方便扩展、久经考验的状态管理解决方案。这个教程旨在十分钟内向你介绍 MobX 的一些重要概念。MobX 是一个独立的苦，不过大多数人都把它和 React 一起使用，所以本教程也就着眼于这个组合展开。 核心概念 State 是每一个应用程序的核心部分，而使用一个不合规范的 State 则是让你的应用充满 bug 和失控的不二法门，或者就是局部变量环绕，让你的 state 失去了同步。有很多框架试图解决这个问题，比如使用不可变的 state，但是这样以来又带来了新的问题，比如数据必须规格化，完整性约束失效等等。 MobX 让整个事情又变简单了：它不允许产生失控的 state。它的理念也很简单：所有可以从 state 中派生的事物，都会自动的派生。 把 MobX 想象成 Excel 表格。 首先，有一个 state，它可以是一个object，array，primitives等等任何组成你程序的部分。你可以把这个想象成你应用程序的“单元格”。 然后就是 derivations，一般它是指可以从 state 中直接计算的来的结果。比如未完成的任务的数量，这个比较简单，也可以稍复杂一些比如渲染你的任务显示的html。它类似于你的应用程序中的“公式和图表”。 Reactions 和 derivations 很像，主要的区别在于 reactions 并不产生数据结果，而是自动完成一些任务，一般是和 I/O 相关的。他们保证了 DOM 和 网络请求会自动适时地出发。 最后是 actions。Actions 指的是所有会改变 state 的事情，MobX 保证所有 actions 都会有对应的 derivations 和 reactions 相伴，保证同步。 一个简单的 todo 的 state 理论说的够多的了，看一个例子也许会更明白一些。我们从一个简单的 todo 程序开始。 下面是一个简单直接的 TodoStore，没有鱼丸，没有粗面，没有 MobX …… JavaScript class TodoStore { todos = []; get completedTodosCount() { return this.todos.filter( todo => todo.completed === true ).length; } report() { if (this.todos.length === 0) return \"\"; return `Next todo: \"${this.todos[0].task}\". ` + `Progress: ${this.completedTodosCount}/${this.todos.length}`; } addTodo(task) { this.todos.push({ task: task, completed: false, assignee: null }); } } const todoStore = new TodoStore(); 我们创建了一个 todoStore，它拥有一个 todos 集合。现在我们往这个 todoStore 里添加一些东西，为了明显起见，我们每修改一个地方，就调用todoStore.report。 todoStore.addTodo(\"read MobX tutorial\"); console.log(todoStore.report()); ​ todoStore.addTodo(\"try MobX\"); console.log(todoStore.report()); ​ todoStore.todos[0].completed = true; console.log(todoStore.report()); ​ todoStore.todos[1].task = \"try MobX in own project\"; console.log(todoStore.report()); ​ todoStore.todos[0].task = \"grok MobX tutorial\"; console.log(todoStore.report()); 到现在为止，没有什么特别的。不过如果我们可以不再手动调用 report 方法，事情会不会更美好一些？我们只需要在想要的地方修改这个 state，所有的汇报都自动来做。 太巧了，这就是 MobX 能为你做的事情。自动执行只在 state 改变的时候触发，就好像 Excel 中的图表只在单元格数据改变时更新一样。为了达到这个目标，TodoStore 必须成为可观测的（observable）才行，让我们来改一些代码。 同时，completedTodosCount 属性应该被自动派生，使用 @observable 和 @computed 装饰器来做这些事情： JavaScript class ObservableTodoStore { @observable todos = []; @observable pendingRequests = 0; constructor() { mobx.autorun(() => console.log(this.report)); } @computed get completedTodosCount() { return this.todos.filter( todo => todo.completed === true ).length; } @computed get report() { if (this.todos.length === 0) return \"\"; return `Next todo: \"${this.todos[0].task}\". ` + `Progress: ${this.completedTodosCount}/${this.todos.length}`; } addTodo(task) { this.todos.push({ task: task, completed: false, assignee: null }); } } const observableTodoStore = new ObservableTodoStore(); class ObservableTodoStore { @observable todos = []; @observable pendingRequests = 0; constructor() { mobx.autorun(() => console.log(this.report)); } @computed get completedTodosCount() { return this.todos.filter( todo => todo.completed === true ).length; } @computed get report() { if (this.todos.length === 0) return \"\"; return `Next todo: \"${this.todos[0].task}\". ` + `Progress: ${this.completedTodosCount}/${this.todos.length}`; } addTodo(task) { this.todos.push({ task: task, completed: false, assignee: null }); } } const observableTodoStore = new ObservableTodoStore(); 运行它，太棒了，我们每次赋值都能获得输出结果了。 有个 pendingRequests 暂时没用到，我们后面会用。另外这个教程都用了 ES6 的写法，不过 MobX 也支持 ES5 的写法。 在这个构造器中，我们使用autorun包裹了一个打出report的小函数。Autorun里的东西首先会运行一次，然后当其中的函数有observable的数据发生变化时，会再次运行。 这里我们使用了todos属性，每次todos变化了我们就打印出新的东西。 JavaScript observableTodoStore.addTodo(\"read MobX tutorial\"); observableTodoStore.addTodo(\"try MobX\"); observableTodoStore.todos[0].completed = true; observableTodoStore.todos[1].task = \"try MobX in own project\"; observableTodoStore.todos[0].task = \"grok MobX tutorial\"; （可以自己试试结果） 非常有趣是吧，report确实自己执行了，而且同步又精准。如果你仔细查看运行结果的话，你挥发性我们的第四句语句没有产生输出，因为我们修改了todos[1]的数据，而我们在report中指明的数据，并没有todos[1]的变化而发生变化。而第五句话修改了todos[0]的数据则输出了。这个例子很好的说明了，autorun不是简单的监视了todos，而是精确到了具体的一项。 让React更美好 好了，到目前未知，我们使report自动化了，是实话把react拉出来遛遛了。为了是的react 的组件可以识别mobx，我们需要使用mobx-react包来完成，使用autorun，自动的让组件和state同步，这个简直就和上面的让report自动输出一样简单。 下面是一个react 组件，唯一MobX出场的地方就是一个@observer修饰符，这已经足够了，你再也不用使用setState了，你也不需要指明这个组件需要关注state的哪个部分，也不许手动写什么高阶组件。一般来说，所有的部件都变成人工智能了，即使他被定义成一个木偶（纯展示）组件。 JavaScript @observer class TodoList extends React.Component { render() { const store = this.props.store; return ( { store.report } { store.todos.map( (todo, idx) => ) } { store.pendingRequests > 0 ? Loading... : null } New Todo (double-click a todo to edit) ); } ​ onNewTodo = () => { this.props.store.addTodo(prompt('Enter a new todo:','coffee plz')); } } ​ @observer class TodoView extends React.Component { render() { const todo = this.props.todo; return ( { todo.task } { todo.assignee ? { todo.assignee.name } : null } ); } ​ onToggleCompleted = () => { const todo = this.props.todo; todo.completed = !todo.completed; } ​ onRename = () => { const todo = this.props.todo; todo.task = prompt('Task name', todo.task) || todo.task; } } ​ ReactDOM.render( , document.getElementById('reactjs-app') ); 执行下面的语句，我们会发现MobX帮我们把数据的更改反应到界面上去了。 JavaScript store.todos[0].completed = !store.todos[0].completed; store.todos[1].task = \"Random todo \" + Math.random(); store.todos.push({ task: \"Find a fine cheese\", completed: true }); // etc etc.. add your own statements here... 使用引用（References) 到现在位置，我们已经使用 observable 创建了个数据类型了。也许你会想，MobX 能不能应付引用呢？在之前的例子里，你可能主意到了又一个 assignee 的属性，我们就在这里放另外的一个 store，然后把它赋值给 tasks。 JavaScript var peopleStore = mobx.observable([ { name: \"Michel\" }, { name: \"Me\" } ]); observableTodoStore.todos[0].assignee = peopleStore[0]; observableTodoStore.todos[1].assignee = peopleStore[1]; peopleStore[0].name = \"Michel Weststrate\"; 毫无疑问的，MobX 把着一切打理的井井有条。使用 MobX ，不需要规格话数据，不需要指明控件，事实上你的数据在哪里都无所谓。只要 observale 了，什么都好了。 总结 好了，仅仅依靠一些简单的修饰器，我们就让 react 程序如此生动有趣。最后总结一些： @observale 修饰器或者 observable 函数让对象可以被追踪； @computed 修饰器创造了自动运算的表达式； autorun 函数让依靠 observable 的函数自动执行，这个用来写 log，发请求很不错； @observer 修饰器让 React 组建自动起来，它会自动更新，即便是在一个很大的程序里也会工作的很好； 最后，MobX 不是一个状态容器 很多人把 MobX 当作另外一个 Redux，但是它仅仅是一个库，不是一个什么架构。上面的例子还是需要程序员自己去组织逻辑和store或者控制器什么的。 "},"React/lifecyce.html":{"url":"React/lifecyce.html","title":"React生命周期","keywords":"","body":"React生命周期 用一个表格表示生命周期 函数 解释 getDefaultProps 作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享 getInitialState 作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props componentWillMount 在完成首次渲染之前调用，此时仍可以修改组件的state render 必选的方法，创建虚拟DOM，该方法具有特殊的规则： 1.只能通过this.props和this.state访问数据 2.可以返回null、false或任何React组件 3.只能出现一个顶级组件（不能返回数组） 4.不能改变组件的状态 5.不能修改DOM的输出 componentDidMount 真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。在服务端中，该方法不会被调用 componentWillReceiveProps 组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state shouldComponentUpdate 组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化 componentWillUpdate 接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state componentDidUpdate 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素 componentWillUnmount 组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器 实例化 首次实例化 getDefaultProps getInitialState componentWillMount render componentDidMount 实例化完成后的更新 getInitialState componentWillMount render componentDidMount 存在期 组件已存在时的状态改变 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 销毁&清理期 componentWillUnmount 说明 生命周期共提供了10个不同的API。 1.getDefaultProps 作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。 2.getInitialState 作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。 3.componentWillMount 在完成首次渲染之前调用，此时仍可以修改组件的state。 4.render 必选的方法，创建虚拟DOM，该方法具有特殊的规则： 只能通过this.props和this.state访问数据 可以返回null、false或任何React组件 只能出现一个顶级组件（不能返回数组） 不能改变组件的状态 不能修改DOM的输出 5.componentDidMount 真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。 在服务端中，该方法不会被调用。 6.componentWillReceiveProps 组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。 componentWillReceiveProps: function(nextProps) { if (nextProps.bool) { this.setState({ bool: true }); } } 7.shouldComponentUpdate 组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。 在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用 8.componentWillUpdate 接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。 9.componentDidUpdate 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。 10.componentWillUnmount 组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。 "},"vue/":{"url":"vue/","title":"vue","keywords":"","body":"vue "},"vue/start.html":{"url":"vue/start.html","title":"项目的搭建","keywords":"","body":"Vue项目搭建 Vue项目搭建非常简单这里就只说一下命令操作 # 全局安装 vue-cli $ npm install --global vue-cli # 创建一个基于 webpack 模板的新项目 $ vue init webpack my-project # 安装依赖，走你 $ cd my-project $ npm install $ npm run dev Vue项目搭建原文地址 "},"vue/router.html":{"url":"vue/router.html","title":"vue-router","keywords":"","body":"vue-router Vue.js的一大特色就是构建单页面应用十分方便，既然要方便构建单页面应用那么自然少不了路由，vue-router就是vue官方提供的一个路由框架。总体来说，vue-router设计得简单好用，下面就来聊聊我实际用到过的一些方法，文章没有提到的可以去查看官方文档。vue-router的安装这里就不提了，相信会来看这篇博客同学，这些基本能力都是有的。 先上例子 商品 评论 商家 // 首先定义或者引入路由的组件 // 方法一：直接定义路由组件 const goods = { template: 'goods' }; const ratings = { template: 'ratings' }; const seller = { template: 'seller' }; // 方法二：import引入路由组件 import goods from 'components/goods/goods'; import ratings from 'components/ratings/ratings'; import seller from 'components/seller/seller'; // 然后定义路由(routes)，components还可以是Vue.extend()创建的 const routes = [ { path: '/goods', component: goods }, { path: '/ratings', component: ratings }, { path: '/seller', component: seller } ]; // 接着创建路由实例 const router = new VueRouter({ // ES6缩写语法，相当于routes:routes routes }); // 最后创建vue实例并挂载 const app = new Vue({ el: '#app', router }); // 或者 const app = new Vue({ router }).$mount('#app') 到这里就可以用vue-router轻松搭建一个单页面应用了。我一般都是使用模块化编程的形式，用.vue单文件，不知道在模块化编程里怎么加载vue-router的可以参考我的某个项目源码。 router-link和router-view 看了上面的例子，一定对router-link和router-view很感兴趣。 router-link 从上面例子中的书写形式就可以看出，router-link是一个组件，它默认会被渲染成一个带有链接的a标签，通过to属性指定链接地址。 注意：被选中的router-link将自动添加一个class属性值.router-link-active。 router-link属性配置 to 这是一个必须设置的属性，否则路由无法生效。它表示路由的链接，可以是一个字符串也可以是一个描述目标位置的对象。 replace 一个布尔类型，默认为false。如果replace设置为true，那么导航不会留下history记录，点击浏览器回退按钮不会再回到这个路由。 tag router-link默认渲染成a标签，也有方法让它渲染成其他标签，tag属性就用来设置router-link渲染成什么标签的。 active-class 上面说了被选中的router-link将自动添加一个class属性值.router-link-active，这个属性就是来修改这个class值的。 router-view 这个组件十分关键，它就是用来渲染匹配到的路由的。 可以给router-view组件设置transition过渡，具体用法见Vue2.0 Transition常见用法全解惑。 还可以配合使用，keep-alive可以缓存数据，这样不至于重新渲染路由组件的时候，之前那个路由组件的数据被清除了。比如对当前的路由组件a进行了一些DOM操作之后，点击进入另一个路由组件b，再回到路由组件a的时候之前的DOM操作还保存在，如果不加keep-alive再回到路由组件a时，之前的DOM操作就没有了，得重新进行。如果你的应用里有一个购物车组件，就需要用到keep-alive。 一些小需求怎么实现 不同路由不同页面标题 多页面应用我们可以给每一个页面都设置一个不同的标题，但是如果是单页面应用的路由呢？其实也是可以实现的，实现的方法不止一种，我之前用的是结合命名路由和导航钩子函数的方法。如下： // 定义路由的时候如下定义，name也可为中文 const routes = [ { path: '/goods', component: goods, name: 'goods' }, { path: '/ratings', component: ratings, name: 'ratings' }, { path: '/seller', component: seller, name: 'seller' } ]; // 创建路由实例 const router = new VueRouter({ routes: routes }) // 关键在这里，设置afterEach钩子函数 router.afterEach((to, from, next) => { document.title = to.name; }) 命名路由 既然用到了命名路由，这里就提一下吧。命名路由就是用一个名称来标识一个路由，在定义路由的时候设置一个name属性即可。在router-link中也可以用路由的名字来链接到一个路由。 seller 导航钩子 这个我还没怎么用过，它主要是用来拦截导航的，想使用的参考官方文档吧。 怎么刚进入应用就渲染某个路由组件 刚进入应用都是进入到“/”这个路由的，如果想直接进入到“/goods”怎么办，这里提供两种方法。一种是利用重定向，另一种是利用vue-router的导航式编程。 重定向 const routes = [ { path: '/', redirect: '/goods'} ] 是不是很简单呢？重定向的目标也可以是一个命名的路由。 const routes = [ { path: '/', redirect: { name: 'goods' }} ] 导航式编程 利用vue-router的导航式编程的router.push方法也可以实现上面的需求。 // 在创建vue实例并挂载后调用 router.push('/goods') router.push方法就是用来动态导航到不同的链接的。它会向history栈添加一个新的记录，点击等同于调用router.push(...)。 vue-router中还有router.replace方法和router.go方法，概念及用法可参考https://router.vuejs.org/zh-cn。 "},"vue/vuex.html":{"url":"vue/vuex.html","title":"vuex","keywords":"","body":"vuex 参考网站 "},"vue/lifecyce.html":{"url":"vue/lifecyce.html","title":"vue生命周期","keywords":"","body":"vue生命周期 下面的表格是1.0+版本与2.0+版本的对比 vue1.0+ vue2.0 解释 init beforeCreate 组件实例刚被创建，组件属性计算之前，如data属性 created created 组件实例创建完成，属性已绑定，但DOM还没生成,$el属性还不存在 beforeCompile beforeMount 模板编译/挂载之前 compiled mounted 模板编译/挂载之后 ready mounted 模板编译/挂载之后 - beforeUpdate 组件更新之前 - updated 组件更新之后 - activated for keep-alive，组件被激活时调用 - deactivated for keep-alive，组件被移除时调用 activated - 不做解释 detached - 不做解释 beforeDestroy beforeDestroy 组件销毁前调用 destroyed destroyed 组件销毁后调用 用代码说清这些 {{ message }} var app = new Vue({ el: '#app', data: { message : \"xuxiao is boy\" }, beforeCreate: function () { console.group('beforeCreate 创建前状态===============》'); console.log(\"%c%s\", \"color:red\" , \"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //undefined console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) }, created: function () { console.group('created 创建完毕状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 }, beforeMount: function () { console.group('beforeMount 挂载前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + (this.$el)); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 }, mounted: function () { console.group('mounted 挂载结束状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 }, beforeUpdate: function () { console.group('beforeUpdate 更新前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); }, updated: function () { console.group('updated 更新完成状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); }, beforeDestroy: function () { console.group('beforeDestroy 销毁前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); }, destroyed: function () { console.group('destroyed 销毁完成状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) } }) 附一张图后面慢慢理解 "},"specialEffects/":{"url":"specialEffects/","title":"特效案例","keywords":"","body":"特效案例 "},"specialEffects/section1.html":{"url":"specialEffects/section1.html","title":"css特效","keywords":"","body":"css特效 先预览效果，从左上角开始从左到右从上到下依次编号为1-12，下边的代码也分别按此序号 1. 时间效果的 html代码 css代码 .timer{ width: 24px; height: 24px; background-color: transparent; box-shadow: inset 0px 0px 0px 2px #fff; border-radius: 50%; position: relative; margin: 38px auto;/* Not necessary- its only for layouting*/ } .timer:after, .timer:before{ position: absolute; content:\"\"; background-color: #fff; } .timer:after{ width: 10px; height: 2px; top: 11px; left: 11px; -webkit-transform-origin: 1px 1px; -moz-transform-origin: 1px 1px; transform-origin: 1px 1px; -webkit-animation: minhand 2s linear infinite; -moz-animation: minhand 2s linear infinite; animation: minhand 2s linear infinite; } .timer:before{ width: 8px; height: 2px; top: 11px; left: 11px; -webkit-transform-origin: 1px 1px; -moz-transform-origin: 1px 1px; transform-origin: 1px 1px; -webkit-animation: hrhand 8s linear infinite; -moz-animation: hrhand 8s linear infinite; animation: hrhand 8s linear infinite; } @-webkit-keyframes minhand{ 0%{-webkit-transform:rotate(0deg)} 100%{-webkit-transform:rotate(360deg)} } @-moz-keyframes minhand{ 0%{-moz-transform:rotate(0deg)} 100%{-moz-transform:rotate(360deg)} } @keyframes minhand{ 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} } @-webkit-keyframes hrhand{ 0%{-webkit-transform:rotate(0deg)} 100%{-webkit-transform:rotate(360deg)} } @-moz-keyframes hrhand{ 0%{-moz-transform:rotate(0deg)} 100%{-moz-transform:rotate(360deg)} } @keyframes hrhand{ 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} } 2. 效果 html代码 css代码 .typing_loader{ width: 6px; height: 6px; border-radius: 50%; -webkit-animation: typing 1s linear infinite alternate; -moz-animation: Typing 1s linear infinite alternate; -ms-animation: Typing 1s linear infinite alternate; animation: typing 1s linear infinite alternate; margin: 46px auto; /* Not necessary- its only for layouting*/ position: relative; left: -12px; } @-webkit-keyframes typing{ 0%{ background-color: rgba(255,255,255, 1); box-shadow: 12px 0px 0px 0px rgba(255,255,255,0.2), 24px 0px 0px 0px rgba(255,255,255,0.2); } 25%{ background-color: rgba(255,255,255, 0.4); box-shadow: 12px 0px 0px 0px rgba(255,255,255,2), 24px 0px 0px 0px rgba(255,255,255,0.2); } 75%{ background-color: rgba(255,255,255, 0.4); box-shadow: 12px 0px 0px 0px rgba(255,255,255,0.2), 24px 0px 0px 0px rgba(255,255,255,1); } } @-moz-keyframes typing{ 0%{ background-color: rgba(255,255,255, 1); box-shadow: 12px 0px 0px 0px rgba(255,255,255,0.2), 24px 0px 0px 0px rgba(255,255,255,0.2); } 25%{ background-color: rgba(255,255,255, 0.4); box-shadow: 12px 0px 0px 0px rgba(255,255,255,2), 24px 0px 0px 0px rgba(255,255,255,0.2); } 75%{ background-color: rgba(255,255,255, 0.4); box-shadow: 12px 0px 0px 0px rgba(255,255,255,0.2), 24px 0px 0px 0px rgba(255,255,255,1); } } @keyframes typing{ 0%{ background-color: rgba(255,255,255, 1); box-shadow: 12px 0px 0px 0px rgba(255,255,255,0.2), 24px 0px 0px 0px rgba(255,255,255,0.2); } 25%{ background-color: rgba(255,255,255, 0.4); box-shadow: 12px 0px 0px 0px rgba(255,255,255,2), 24px 0px 0px 0px rgba(255,255,255,0.2); } 75%{ background-color: rgba(255,255,255, 0.4); box-shadow: 12px 0px 0px 0px rgba(255,255,255,0.2), 24px 0px 0px 0px rgba(255,255,255,1); } } 3. 效果 html代码 css代码 .location_indicator{ margin: 30px auto; position: relative; left: -9px; } .location_indicator:before, .location_indicator:after{ position: absolute; content: \"\"; } .location_indicator:before{ width: 20px; height: 20px; border-radius: 100% 100% 100% 0; box-shadow: 0px 0px 0px 2px rgba(255,255,255,1); -webkit-animation: mapping 1s linear infinite; -moz-animation: mapping 1s linear infinite; animation: mapping 1s linear infinite; -webkit-transform: rotate(-46deg); -moz-transform: rotate(-46deg); transform: rotate(-46deg); } .location_indicator:after{ width: 30px; height: 10px; border-radius: 100%; left: 44px; background-color: rgba(255, 255, 255, 0.2); top: 24px; z-index: -1; } @-webkit-keyframes mapping{ 0% {top: 0;} 50%{top: -5px;} 100% {top:0; } } @-moz-keyframes mapping{ 0% {top: 0;} 50%{top: -5px;} 100% {top:0; } } @-keyframes mapping{ 0% {top: 0;} 50%{top: -5px;} 100% {top:0; } } 4. 效果 html代码 css代码 .dashboard{ width: 32px; height: 32px; margin: 30px auto; border: 2px rgba(255,255,255,1) solid; border-radius: 100%; position: relative; overflow: hidden; z-index: 1; } .dashboard:after, .dashboard:before{ position: absolute; content: \"\"; } .dashboard:after{ width:14px; height: 2px; top: 20px; -webkit-transform-origin: 1px 1px; -moz-transform-origin: 1px 1px; transform-origin: 1px 1px; background-color: rgba(255,255,255,1); -webkit-animation: dashboard_hand 2s linear infinite alternate; -moz-animation: dashboard_hand 2s linear infinite alternate; animation: dashboard_hand 2s linear infinite alternate; } .dashboard:before{ width: 32px; height: 10px; background-color: rgba(255,255,255,1); top:20px; left: -2px; } @-webkit-keyframes dashboard_hand{ 0%{ -webkit-transform: rotate(-160deg);} 100%{ -webkit-transform: rotate(-20deg);} } @-moz-keyframes dashboard_hand{ 0%{ -moz-transform: rotate(-160deg);} 100%{ -moz-transform: rotate(-20deg);} } @keyframes dashboard_hand{ 0%{ transform: rotate(-160deg);} 100%{ transform: rotate(-20deg);} } 5. 效果 html代码 css代码 .battery{ width: 28px; height: 14px; border: 1px #fff solid; border-radius: 2px; position: relative; -webkit-animation: charge 5s linear infinite; -moz-animation: charge 5s linear infinite; animation: charge 5s linear infinite; top: 40px; margin: 0 auto; } .battery:after{ width: 2px; height: 7px; background-color: #fff; border-radius: 0px 1px 1px 0px; position: absolute; content: \"\"; top: 2px; right: -4px; } @-webkit-keyframes charge{ 0%{box-shadow: inset 0px 0px 0px #fff;} 100%{box-shadow: inset 30px 0px 0px #fff;} } @-moz-keyframes charge{ 0%{box-shadow: inset 0px 0px 0px #fff;} 100%{box-shadow: inset 30px 0px 0px #fff;} } @keyframes charge{ 0%{box-shadow: inset 0px 0px 0px #fff;} 100%{box-shadow: inset 30px 0px 0px #fff;} } 6. 效果 html代码 css代码 .magnifier{ width: 20px; height: 20px; box-shadow: 0px 0px 0px 1px #fff; border-radius: 50%; position: relative; margin: 34px auto; -webkit-animation: magnify 1s linear infinite alternate; -moz-animation: magnify 1s linear infinite alternate; animation: magnify 1s linear infinite alternate; } .magnifier:after, .magnifier:before{ position: absolute; content: \"\"; } .magnifier:before{ content: \"me\"; font-size: 12px; left: 2px; text-align: center; top: 2px; } .magnifier:after{ width: 2px; height: 8px; background-color: #fff; bottom: -6px; left: 20px; border-radius: 2px; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); transform: rotate(-45deg); } @-webkit-keyframes magnify{ 0%{-webkit-transform: scale(1); } 100%{-webkit-transform: scale(1.5);} } @-moz-keyframes magnify{ 0%{-moz-transform: scale(1); } 100%{-moz-transform: scale(1.5);} } @keyframes magnify{ 0%{transform: scale(1); } 100%{transform: scale(1.5);} } 7. 效果 html代码 css代码 .help{ width: 30px; height: 30px; border: 1px #fff solid; border-radius: 50%; -webkit-animation: rotation 1s ease-in-out infinite; -moz-animation: rotation 1s ease-in-out infinite; animation: rotation 1s ease-in-out infinite; margin: 30px auto; } .help:after{ width: 5px; height: 5px; background-color: rgba(255,255,255,1); border-radius: 100%; position: absolute; content: \"\"; } @-webkit-keyframes rotation{ 0%{-webkit-transform: rotate(0deg);} 100%{-webkit-transform: rotate(360deg);} } @-moz-keyframes rotation{ 0%{-moz-transform: rotate(0deg);} 100%{-moz-transform: rotate(360deg);} } @keyframes rotation{ 0%{transform: rotate(0deg);} 100%{transform: rotate(360deg);} } 8. 效果 html代码 css代码 .cloud{ margin: 42px 30px; width: 4px; height: 10px; opacity: 0.5; position: relative; box-shadow: 6px 0px 0px 0px rgba(255,255,255,1), 12px 0px 0px 0px rgba(255,255,255,1), 18px 0px 0px 0px rgba(255,255,255,1), 24px 0px 0px 0px rgba(255,255,255,1), 30px 0px 0px 0px rgba(255,255,255,1), 36px 0px 0px 0px rgba(255,255,255,1); -webkit-animation: rain 1s linear infinite alternate; -moz-animation: rain 1s linear infinite alternate; animation: rain 1s linear infinite alternate; } .cloud:after{ width: 40px; height: 10px; position: absolute; content: \"\"; background-color: rgba(255,255,255,1); top: 0px; opacity: 1; -webkit-animation: line_flow 2s linear infinite reverse; -moz-animation: line_flow 2s linear infinite reverse; animation: line_flow 2s linear infinite reverse; } @-webkit-keyframes rain{ 0%{ box-shadow: 6px 0px 0px 0px rgba(255,255,255,1), 12px 0px 0px 0px rgba(255,255,255,0.9), 18px 0px 0px 0px rgba(255,255,255,0.7), 24px 0px 0px 0px rgba(255,255,255,0.6), 30px 0px 0px 0px rgba(255,255,255,0.3), 36px 0px 0px 0px rgba(255,255,255,0.2); } 100%{ box-shadow: 6px 0px 0px 0px rgba(255,255,255,0.2), 12px 0px 0px 0px rgba(255,255,255,0.3), 18px 0px 0px 0px rgba(255,255,255,0.6), 24px 0px 0px 0px rgba(255,255,255,0.7), 30px 0px 0px 0px rgba(255,255,255,0.9), 36px 0px 0px 0px rgba(255,255,255,1); opacity: 1; } } @-moz-keyframes rain{ 0%{ box-shadow: 6px 0px 0px 0px rgba(255,255,255,1), 12px 0px 0px 0px rgba(255,255,255,0.9), 18px 0px 0px 0px rgba(255,255,255,0.7), 24px 0px 0px 0px rgba(255,255,255,0.6), 30px 0px 0px 0px rgba(255,255,255,0.3), 36px 0px 0px 0px rgba(255,255,255,0.2); } 100%{ box-shadow: 6px 0px 0px 0px rgba(255,255,255,0.2), 12px 0px 0px 0px rgba(255,255,255,0.3), 18px 0px 0px 0px rgba(255,255,255,0.6), 24px 0px 0px 0px rgba(255,255,255,0.7), 30px 0px 0px 0px rgba(255,255,255,0.9), 36px 0px 0px 0px rgba(255,255,255,1); opacity: 1; } } @keyframes rain{ 0%{ box-shadow: 6px 0px 0px 0px rgba(255,255,255,1), 12px 0px 0px 0px rgba(255,255,255,0.9), 18px 0px 0px 0px rgba(255,255,255,0.7), 24px 0px 0px 0px rgba(255,255,255,0.6), 30px 0px 0px 0px rgba(255,255,255,0.3), 36px 0px 0px 0px rgba(255,255,255,0.2); } 100%{ box-shadow: 6px 0px 0px 0px rgba(255,255,255,0.2), 12px 0px 0px 0px rgba(255,255,255,0.3), 18px 0px 0px 0px rgba(255,255,255,0.6), 24px 0px 0px 0px rgba(255,255,255,0.7), 30px 0px 0px 0px rgba(255,255,255,0.9), 36px 0px 0px 0px rgba(255,255,255,1); opacity: 1; } } @-webkit-keyframes line_flow{ 0%{ width: 0px;} 100%{width: 40px;} } @-moz-keyframes line_flow{ 0%{ width: 0px;} 100%{width: 40px;} } @keyframes line_flow{ 0%{ width: 0px;} 100%{width: 40px;} } 9. 效果 html代码 css代码 .eye{ width: 20px; height: 20px; background-color: rgba(255,255,255,0.8); border-radius: 50%; box-shadow: 30px 0px 0px 0px rgba(255,255,255,0.8); position: relative; margin: 36px 26px; } .eye:after{ background-color: #59488b; width: 10px; height: 10px; box-shadow: 30px 0px 0px 0px #59488b; border-radius: 50%; left: 9px; top: 8px; position: absolute; content: \"\"; -webkit-animation: eyeball 2s linear infinite alternate; -moz-animation: eyeball 2s linear infinite alternate; animation: eyeball 2s linear infinite alternate; } @-webkit-keyframes eyeball{ 0%{left: 9px;} 100%{left: 1px;} } @-moz-keyframes eyeball{ 0%{left: 9px;} 100%{left: 1px;} } @keyframes eyeball{ 0%{left: 9px;} 100%{left: 1px;} } 10. 效果 html代码 css代码 .coffee_cup{ width: 20px; height: 24px; border: 1px rgba(255,255,255,1) solid; border-radius: 0px 0px 5px 5px; position: relative; margin: 36px auto; } .coffee_cup:after, .coffee_cup:before{ position: absolute; content: \"\"; } .coffee_cup:after{ width: 5px; height: 12px; border: 1px #fff solid; border-left: none; border-radius: 0px 20px 20px 0px; left: 20px; } .coffee_cup:before{ width: 1px; height: 6px; background-color: rgba(255,255,255,1); top: -10px; left: 4px; box-shadow: 5px 0px 0px 0px rgba(255,255,255,1), 5px -5px 0px 0px rgba(255,255,255,1), 10px 0px 0px 0px rgba(255,255,255,1); -webkit-animation: steam 1s linear infinite alternate; -moz-animation: steam 1s linear infinite alternate; animation: steam 1s linear infinite alternate; } @-webkit-keyframes steam{ 0%{height: 0px;} 100%{height: 6px;} } @-moz-keyframes steam{ 0%{height: 0px} 100%{height: 6px;} } @keyframes steam{ 0%{height: 0px} 100%{height: 6px;} } 11. 效果 html代码 css代码 .square{ width: 20px; height: 20px; border:1px rgba(255,255,255,1) solid; margin: 36px auto; position: relative; -webkit-animation: fill_color 5s linear infinite; -moz-animation: fill_color 5s linear infinite; animation: fill_color 5s linear infinite; } .square:after{ width: 4px; height: 4px; position: absolute; content: \"\"; background-color: rgba(255,255,255,1); top: -8px; left: 0px; -webkit-animation: square_check 1s ease-in-out infinite; -moz-animation: square_check 1s ease-in-out infinite; animation: square_check 1s ease-in-out infinite; } @-webkit-keyframes square_check{ 25%{ left: 22px; top: -8px;} 50%{ left: 22px; top: 22px;} 75%{ left: -9px; top: 22px;} 100%{ left: -9px; top: -7px;} } @-moz-keyframes square_check{ 25%{ left: 22px; top: -8px;} 50%{ left: 22px; top: 22px;} 75%{ left: -9px; top: 22px;} 100%{ left: -9px; top: -7px;} } @keyframes square_check{ 25%{ left: 22px; top: -8px;} 50%{ left: 22px; top: 22px;} 75%{ left: -9px; top: 22px;} 100%{ left: -9px; top: -7px;} } @-webkit-keyframes fill_color{ 0%{ box-shadow: inset 0px 0px 0px 0px rgba(255,255,255,0.1);} 100%{ box-shadow: inset 0px -20px 0px 0px rgba(255,255,255,1);} } @-moz-keyframes fill_color{ 0%{ box-shadow: inset 0px 0px 0px 0px rgba(255,255,255,0.1);} 100%{ box-shadow: inset 0px -20px 0px 0px rgba(255,255,255,1);} } @keyframes fill_color{ 0%{ box-shadow: inset 0px 0px 0px 0px rgba(255,255,255,0.1);} 100%{ box-shadow: inset 0px -20px 0px 0px rgba(255,255,255,1);} } 12. 效果 html代码 css代码 .circle{ margin: 40px auto; position: relative; width: 8px; height: 8px; background-color: rgba(255,255,255,.5);; box-shadow: -14px 0px 0px rgba(255,255,255,1); border-radius: 50%; -webkit-animation: circle_classic 1s ease-in-out infinite alternate; -moz-animation: circle_classic 1s ease-in-out infinite alternate; animation: circle_classic 1s ease-in-out infinite alternate; } @-webkit-keyframes circle_classic{ 0%{ opacity: 0.1; -webkit-transform: rotate(0deg) scale(0.5);} 100%{opacity: 1; -webkit-transform: rotate(360deg) scale(1.2);} } @-moz-keyframes circle_classic{ 0%{ opacity: 0.1; -moz-transform: rotate(0deg) scale(0.5);} 100%{opacity: 1; -moz-transform: rotate(360deg) scale(1.2);} } @keyframes circle_classic{ 0%{ opacity: 0.1; transform: rotate(0deg) scale(0.5);} 100%{opacity: 1; transform: rotate(360deg) scale(1.2);} } "},"specialEffects/section2.html":{"url":"specialEffects/section2.html","title":"svg特效","keywords":"","body":"svg特效 "},"CSS/":{"url":"CSS/","title":"CSS实现的一些效果","keywords":"","body":"CSS实现的一些效果 "},"CSS/ellipsis.html":{"url":"CSS/ellipsis.html","title":"CSS实现单行多行添加省略号","keywords":"","body":"CSS实现单行多行添加省略号 先介绍一下单行文本添加省略号的css代码 以下代码实现的效果为下图 overflow: hidden; text-overflow:ellipsis; white-space: nowrap; 先介绍一下多行文本添加省略号的css代码 以下代码实现的效果为下图 display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; 先介绍一下多行文本添加省略号的css代码的优化 以下代码实现的效果为下图 div{position: relative; line-height: 20px; max-height: 40px;overflow: hidden;} div::after{content: \"...\"; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: -webkit-linear-gradient(left, transparent, #fff 55%); background: -o-linear-gradient(right, transparent, #fff 55%); background: -moz-linear-gradient(right, transparent, #fff 55%); background: linear-gradient(to right, transparent, #fff 55%); } "},"CSS/layout.html":{"url":"CSS/layout.html","title":"CSS常见布局解决方案","keywords":"","body":"CSS常见布局解决方案 水平居中布局 1.margin + 定宽 Demo .child { width: 100px; margin: 0 auto; } 2. table + margin Demo .child { display: table; margin: 0 auto; } display: table 在表现上类似 block 元素，但是宽度为内容宽。 无需设置父元素样式 （支持 IE 8 及其以上版本）兼容 IE 8 一下版本需要调整为 table 3.inline-block + text-align Demo .child { display: inline-block; } .parent { text-align: center; } 兼容性佳（甚至可以兼容 IE 6 和 IE 7）4.absolute + margin-left Demo .parent { position: relative; } .child { position: absolute; left: 50%; width: 100px; margin-left: -50px; /* width/2 */ } 宽度固定 相比于使用transform ，有兼容性更好 5. absolute + transform Demo .parent { position: relative; } .child { position: absolute; left: 50%; transform: translateX(-50%); } 绝对定位脱离文档流，不会对后续元素的布局造成影响。 transform 为 CSS3 属性，有兼容性问题 6. flex + justify-content Demo .parent { display: flex; justify-content: center; } 只需设置父节点属性，无需设置子元素 flex有兼容性问题 垂直居中 1.table-cell + vertical-align Demo .parent { display: table-cell; vertical-align: middle; } 兼容性好(IE 8以下版本需要调整页面结构至 table 2.absolute + transform Demo .parent { position: relative; } .child { position: absolute; top: 50%; transform: translateY(-50%); } 绝对定位脱离文档流，不会对后续元素的布局造成影响。但如果绝对定位元素是唯一的元素则父元素也会失去高度。 transform 为 CSS3 属性，有兼容性问题 3.flex + align-items Demo .parent { display: flex; align-items: center; } 水平垂直居中 1. absolute + transform Demo .parent { position: relative; } .child { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } 绝对定位脱离文档流，不会对后续元素的布局造成影响。 transform 为 CSS3 属性，有兼容性问题 2. inline-block + text-align + table-cell + vertical-align Demo .parent { text-align: center; display: table-cell; vertical-align: middle; } .child { display: inline-block; } 兼容性好 3. flex + justify-content + align-items Demo .parent { display: flex; justify-content: center; /* 水平居中 */ align-items: center; /*垂直居中*/ } 只需设置父节点属性，无需设置子元素 蛋疼的兼容性问题 一列定宽，一列自适应 1.float + margin left right right .left { float: left; width: 100px; } .right { margin-left: 100px /*间距可再加入 margin-left */ } IE 6 中会有3像素的 BUG，解决方法可以在 .left 加入 margin-left:-3px 当然也有解决这个小bug的方案如下： left right right .left { float: left; width: 100px; } .right-fix { float: right; width: 100%; margin-left: -100px; } .right { margin-left: 100px /*间距可再加入 margin-left */ } 此方法不会存在 IE 6 中3像素的 BUG，但 .left 不可选择， 需要设置 .left {position: relative} 来提高层级。 注意此方法增加了不必要的 HTML 文本结构。 2.float + overflow left right right .left { float: left; width: 100px; } .right { overflow: hidden; } 设置 overflow: hidden 会触发 BFC 模式（Block Formatting Context）块级格式上下文。BFC是什么呢。用通俗的来讲就是，随便你在BFC 里面干啥，外面都不会受到影响 。此方法样式简单但不支持 IE 6 3.table left right right .parent { display: table; width: 100%; table-layout: fixed; } .left { display: table-cell; width: 100px; } .right { display: table-cell; /*宽度为剩余宽度*/ } table 的显示特性为每列的单元格宽度和一定等与表格宽度。 table-layout: fixed 可加速渲染，也是设定布局优先。table-cell 中不可以设置 margin 但是可以通过 padding 来设置间距 4.flex left right right .parent { display: flex; } .left { width: 100px; margin-left: 20px; } .right { flex: 1; } 低版本浏览器兼容问题 性能问题，只适合小范围布局 等分布局 1.float 1 2 3 4 .parent { margin-left: -20px; } .column { float: left; width: 25%; padding-left: 20px; box-sizing: border-box; } 此方法可以完美兼容 IE8 以上版本 2.flex 1 2 3 4 .parent { display: flex; } .column { flex: 1; } .column+.column { /* 相邻兄弟选择器 */ margin-left: 20px; } 强大简单，有兼容问题 3.table 1 2 3 4 .parent-fix { margin-left: -20px; } .parent { display: table; width: 100%; /*可以布局优先，也可以单元格宽度平分在没有设置的情况下*/ table-layout: fixed; } .column { display: table-cell; padding-left: 20px; } 等高布局 1.table left right right .parent { display: table; width: 100%; table-layout: fixed; } .left { display: table-cell; width: 100px; } .right { display: table-cell /*宽度为剩余宽度*/ } 2.flex left right right .parent { display: flex; } .left { width: 100px; margin-left: 20px; } .right { flex: 1; } 注意这里实际上使用了 align-items: stretch，flex 默认的 align-items 的值为 stretch 3.float left right right .parent { overflow: hidden; } .left, .right { padding-bottom: 9999px; margin-bottom: -9999px; } .left { float: left; width: 100px; margin-right: 20px; } .right { overflow: hidden; } 此方法为伪等高（只有背景显示高度相等），左右真实的高度其实不相等。 兼容性较好。 到此，我们了解常见的布局解决方案，这些只是参考，一样的布局实现方式多种多样。主要就使用position、flex 、table（从很久很久以前起，我们就抛弃了table布局页面，但display: table;是异常强大）、float等属性目前flex兼容性较差 傲娇的程序员应该放弃太低版本的浏览器 "},"conclusion/":{"url":"conclusion/","title":"开发总结","keywords":"","body":"CSS "},"conclusion/phone.html":{"url":"conclusion/phone.html","title":"手机端开发注意事项","keywords":"","body":"手机端开发目常见问题及注意事项 Meta基础知识： H5页面窗口自动调整到设备宽度，并禁止用户缩放页面 // 2、JS动态判断 var phoneWidth = parseInt(window.screen.width); var phoneScale = phoneWidth/640; var ua = navigator.userAgent; if (/Android (\\d+\\.\\d+)/.test(ua)){ var version = parseFloat(RegExp.$1); if(version>2.3){ document.write(''); }else{ document.write(''); } } else { document.write(''); } H5空白页基本meta标签 PC端基础meta标签 页面缓存设置 其他meta标签 常见问题： 移动端如何定义字体font-family @ --------------------------------------中文字体的英文名称 @ 宋体 SimSun @ 黑体 SimHei @ 微信雅黑 Microsoft Yahei @ 微软正黑体 Microsoft JhengHei @ 新宋体 NSimSun @ 新细明体 MingLiU @ 细明体 MingLiU @ 标楷体 DFKai-SB @ 仿宋 FangSong @ 楷体 KaiTi @ 仿宋_GB2312 FangSong_GB2312 @ 楷体_GB2312 KaiTi_GB2312 @ @ 说明：中文字体多数使用宋体、雅黑，英文用Helvetica body { font-family: Microsoft Yahei,SimSun,Helvetica; } 打电话发短信写邮件怎么实现 打电话给:0755-10086 发短信给: 10086 点击我发邮件 点击我发邮件 点击我发邮件 点击我发邮件 点击我发邮件 点击我发邮件 点击我发邮件 \">点击我发邮件 \">点击我发邮件 移动端touch事件（区分webkit和winphone） // 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 // 以下支持webkit touchstart // 当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove // 当手指在屏幕上滑动时连续触发。通常我们在滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend // 当手指离开屏幕时触发 touchcancel // 系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 //TouchEvent说明： touches：屏幕上所有手指的信息 targetTouches：手指在目标区域的手指信息 changedTouches：最近一次触发该事件的手指信息 touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息 //参数信息(changedTouches[0]) clientX、clientY在显示区的坐标 target：当前元素 //事件响应顺序 ontouchstart > ontouchmove > ontouchend > onclick // 以下支持winphone 8 MSPointerDown // 当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove // 当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp // 当手指离开屏幕时触发 移动端click屏幕产生200-300ms的延时响应 说明：移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。 以下是历史原因，来源一个公司内一个同事的分享：2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题 Rentina显示屏原理及设计方案 说明：retina屏是一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个。 在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。 那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 /* 例如图片宽高为：200px*200px，那么写法如下 */ .css { width:100px; height:100px; background-size:100px 100px; } /* 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px */ .css { font-size:20px } /* image-set设计Rentina背景图 */ image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。 .css { background: url(images/bg.jpg) no-repeat center; background: -webkit-image-set( url(images/bg.jpg) 1x, /* 支持image-set普通屏 */ url(images/bg-2x.jpg) 2x); /* 支持image-set的Rentinan */ } 点击元素产生背景或边框怎么去掉 ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0去除灰色半透明遮罩； android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果； winphone系统,点击标签产生的灰色半透明背景，能通过设置去掉； 特殊说明：有些机型去除不了，如小米2。对于按钮类还有个办法，不使用a或者input标签，直接用div标签 a,button,input,textarea { -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-user-modify:read-write-plaintext-only; /* -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符 */ } /* 也可以 */ * { -webkit-tap-highlight-color: rgba(0,0,0,0); } /* winphone下 */ 美化表单元素 /* 一、使用appearance改变webkit浏览器的默认外观 */ input,select { -webkit-appearance:none; appearance: none; } /* 二、winphone下，使用伪元素改变表单元素默认外观 */ /* 1.禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰 */ select::-ms-expand { display:none; } /* 2.禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰 */ input[type=radio]::-ms-check, input[type=checkbox]::-ms-check { display:none; } /* 3.禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰 */ input[type=text]::-ms-clear, input[type=tel]::-ms-clear, input[type=number]::-ms-clear { display:none; } 移动端字体单位font-size选择px还是rem /* 如需适配多种移动设备，建议使用rem。以下为参考值： */ html { font-size: 62.5%; } /* 10*16 = 62.5% */ /* 设置12px字体，这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级 */ body { font-size:12px; font-size:1.2rem; } 超实用的CSS样式 /* 去掉webkit的滚动条——display: none; */ /* 其他参数 */ ::-webkit-scrollba /* 滚动条整体部分 */ ::-webkit-scrollbar-thumb /* 滚动条内的小方块 */ ::-webkit-scrollbar-track /* 滚动条轨道 */ ::-webkit-scrollbar-button /* 滚动条轨道两端按钮 */ ::-webkit-scrollbar-track-piece /* 滚动条中间部分，内置轨道 */ ::-webkit-scrollbar-corner /* 边角，两个滚动条交汇处 */ ::-webkit-resizer /* 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件 */ /* 禁止长按链接与图片弹出菜单 */ a,img { -webkit-touch-callout: none } /* 禁止ios和android用户选中文字 */ html,body { -webkit-user-select:none; user-select: none; } /* 改变输入框placeholder的颜色值 */ ::-webkit-input-placeholder { /* WebKit browsers */ color: #999; } :-moz-placeholder { /* Mozilla Firefox 4 to 18 */ color: #999; } ::-moz-placeholder { /* Mozilla Firefox 19+ */ color: #999; } :-ms-input-placeholder { /* Internet Explorer 10+ */ color: #999; } input:focus::-webkit-input-placeholder{ color:#999; } /* android上去掉语音输入按钮 */ input::-webkit-input-speech-button {display: none} /* 阻止windows Phone的默认触摸事件 */ /* 说明：winphone下默认触摸事件事件使用`e.preventDefault`是无效的，可通过样式来禁用，如：*/ html { -ms-touch-action:none; } /* 禁止winphone默认触摸事件 */ 取消input在ios下，输入的时候英文首字母的默认大写 手机拍照和上传图片 屏幕旋转的事件和样式 // JS处理 function orientInit(){ var orientChk = document.documentElement.clientWidth > document.documentElement.clientHeight?'landscape':'portrait'; if (orientChk =='lapdscape'){ // 这里是横屏下需要执行的事件 } else { // 这里是竖屏下需要执行的事件 } } orientInit(); window.addEventListener('onorientationchange' in window?'orientationchange':'resize', function(){ setTimeout(orientInit, 100); },false) /* CSS处理 */ /* 竖屏时样式 */ @media all and (orientation:portrait){ } /* 横屏时样式 */ @media all and (orientation:landscape){ } audio元素和video元素在ios和andriod中无法自动播放 你的浏览器还不支持哦 优先播放音乐bg.ogg，不支持在播放bg.mp3 // JS绑定自动播放（操作window时，播放音乐） $(window).one('touchstart', function(){ music.play(); }) // 微信下兼容处理 document.addEventListener(\"WeixinJSBridgeReady\", function () { music.play(); }, false); // 小结 // 1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常 // 2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间 重力感应事件 // 运用HTML5的deviceMotion，调用重力感应事件 if(window.DeviceMotionEvent){ document.addEventListener('devicemotion', deviceMotionHandler, false) } var speed = 30; var x = y = z = lastX = lastY = lastZ = 0; function deviceMotionHandler(eventData){ var acceleration = event.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX)>speed || Math.abs(y-lastY)>speed || Math.abs(z-lastZ)>speed ){ // 这里是摇动后要执行的方法 yaoAfter(); } lastX = x; lastY = y; lastZ = z; } function yaoAfter(){ // do something } // 说明：说见案例摇一摇效果中yao.js 微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整 // 以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理 if (typeof(WeixinJSBridge) == \"undefined\") { document.addEventListener(\"WeixinJSBridgeReady\", function (e) { setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize':0}, function(res){ alert(JSON.stringify(res)); }) }, 0) }); }else{ setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize':0}, function(res){ alert(JSON.stringify(res)); }) }, 0) } /* IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小 */ body { -webkit-text-size-adjust:100%!important; } /* 最好的解决方案：最好使用rem或百分比布局 */ 定位的坑 fixed定位 ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位 android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 ios4下不支持position:fixed 解决方案：使用Iscroll，如： ..... var myscroll; function loaded(){ myscroll=new iScroll(\"wrapper\"); } window.addEventListener(\"DOMContentLoaded\",loaded,false); position定位 Android下弹出软键盘弹出时，影响absolute元素定位 //解决方案: var ua = navigator.userAgent.indexOf('Android'); if(ua>-1){ $('.ipt').on('focus', function(){ $('.css').css({'visibility':'hidden'}) }).on('blur', function(){ $('.css').css({'visibility':'visible'}) }) } 播放视频不全屏 JS判断设备 function deviceType(){ var ua = navigator.userAgent; var agent = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; for(var i=0; i0){ break; } } } deviceType(); window.addEventListener('resize', function(){ deviceType(); }) JS判断微信浏览器 function isWeixin(){ var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)=='micromessenger'){ return true; }else{ return false; } } android 2.3 bug //1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉 //2.after和before伪类无法使用动画animation //3.border-radius不支持%单位，如要兼容，可以给radius设置一下较大的值 //4.translate百分比的写法和scale在一起会导致失效，例如： -webkit-transform: translate(-50%,-50%) scale(-0.5, 1) android 4.x bug //1.三星 Galaxy S4中自带浏览器不支持border-radius缩写 //2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分 //3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色 //4.android无法同时播放多音频audio 消除transition闪屏 .css { -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000; } 开启硬件加速 目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。 .css { -webkit-transform: translate3d(0,0,0); -moz-transform: translate3d(0,0,0); -ms-transform: translate3d(0,0,0); transform: translate3d(0,0,0); } 渲染优化 1、禁止使用iframe（阻塞父文档onload事件） 2、禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能） 3、使用CSS3代码代替JS动画； 4、开启GPU加速； 5、使用base64位编码图片(仅小图而言，大图不建议使用) 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU。小图标优势在于： 减少HTTP请求； 避免文件跨域； 修改及时生效； 腾讯方案 var autoScale = function(){ var ratio = 320/504, //这是设计稿的宽高比（504是Iphone的高度去掉标题栏高度） winW = document.getElement.clientWidth, winH = document.getElement.clientHeight, ratio2 = winW/winH, scale; if(ratio"},"conclusion/section2.html":{"url":"conclusion/section2.html","title":"电脑桌面应用开发","keywords":"","body":"电脑端桌面应用开发注意事项 "},"node/":{"url":"node/","title":"node","keywords":"","body":"node "},"node/section1.html":{"url":"node/section1.html","title":"node简单爬虫","keywords":"","body":"第一节 "},"node/section2.html":{"url":"node/section2.html","title":"node-express","keywords":"","body":"第二节 "},"three/":{"url":"three/","title":"three","keywords":"","body":"three "},"three/section1.html":{"url":"three/section1.html","title":"Three.js常量","keywords":"","body":"Three.js常量 自定义混合方程 方程式(Equations) THREE.AddEquation THREE.SubtractEquation THREE.ReverseSubtractEquation THREE.MinEquation THREE.MaxEquation 指定系数(Destination Factors) THREE.ZeroFactor THREE.OneFactor THREE.SrcColorFactor THREE.OneMinusSrcColorFactor THREE.SrcAlphaFactor THREE.OneMinusSrcAlphaFactor THREE.DstAlphaFactor THREE.OneMinusDstAlphaFactor 来源因子(Source Factors) THREE.DstColorFactor THREE.OneMinusDstColorFactor THREE.SrcAlphaSaturateFactor Source GL状态 Cull Face THREE.CullFaceNone THREE.CullFaceBack THREE.CullFaceFront THREE.CullFaceFrontBack Front Face Direction THREE.FrontFaceDirectionCW THREE.FrontFaceDirectionCCW 材质 Side THREE.FrontSide THREE.BackSide THREE.DoubleSide Shading THREE.FlatShading THREE.SmoothShading Colors THREE.NoColors THREE.FaceColors THREE.VertexColors Blending Mode THREE.NoBlending THREE.NormalBlending THREE.AdditiveBlending THREE.SubtractiveBlending THREE.MultiplyBlending THREE.CustomBlending Depth Mode THREE.NeverDepth THREE.AlwaysDepth THREE.LessDepth THREE.LessEqualDepth THREE.GreaterEqualDepth THREE.GreaterDepth THREE.NotEqualDepth 阴影类型 Shadow Map THREE.BasicShadowMap THREE.PCFShadowMap THREE.PCFSoftShadowMap 纹理 Operations THREE.MultiplyOperation THREE.MixOperation THREE.AddOperation Mapping Modes THREE.UVMapping THREE.CubeReflectionMapping THREE.CubeRefractionMapping THREE.EquirectangularReflectionMapping THREE.EquirectangularRefractionMapping THREE.SphericalReflectionMapping Wrapping Modes THREE.RepeatWrapping THREE.ClampToEdgeWrapping THREE.MirroredRepeatWrapping Filters THREE.NearestFilter THREE.NearestMipMapNearestFilter THREE.NearestMipMapLinearFilter THREE.LinearFilter THREE.LinearMipMapNearestFilter THREE.LinearMipMapLinearFilter Data Types THREE.UnsignedByteType THREE.ByteType THREE.ShortType THREE.UnsignedShortType THREE.IntType THREE.UnsignedIntType THREE.FloatType THREE.HalfFloatType Pixel Types THREE.UnsignedShort4444Type THREE.UnsignedShort5551Type THREE.UnsignedShort565Type Pixel Formats THREE.AlphaFormat THREE.RGBFormat THREE.RGBAFormat THREE.LuminanceFormat THREE.LuminanceAlphaFormat THREE.RGBEFormat DDS / ST3C Compressed Texture Formats THREE.RGB_S3TC_DXT1_Format THREE.RGBA_S3TC_DXT1_Format THREE.RGBA_S3TC_DXT3_Format THREE.RGBA_S3TC_DXT5_Format PVRTC Compressed Texture Formats THREE.RGB_PVRTC_4BPPV1_Format THREE.RGB_PVRTC_2BPPV1_Format THREE.RGBA_PVRTC_4BPPV1_Format THREE.RGBA_PVRTC_2BPPV1_Format "},"three/section2.html":{"url":"three/section2.html","title":"摄像机","keywords":"","body":"摄像机 立体摄像机 正交相机 透视相机 "},"three/section3.html":{"url":"three/section3.html","title":"核心方法","keywords":"","body":"核心方法 缓冲区的属性 缓冲结构 时钟 事件发送者 Face3 几何 3D对象 Raycaster "},"three/section4.html":{"url":"three/section4.html","title":"灯光","keywords":"","body":"灯光 环境光 平行光 半球放射光 光源 点光 聚光灯 "},"three/section5.html":{"url":"three/section5.html","title":"加载器","keywords":"","body":"加载器 巴比伦加载器 几何缓冲加载器 缓存 三维模型加载 glTF加载 图片加载 JSON数据加载 加载器 加载中管理 材质加载 MTL加载 OBJ加载 OBJMTL加载 对象加载 PDB加载 SVG加载 纹理加载 TGA加载 异步加载 "},"three/section6.html":{"url":"three/section6.html","title":"材质","keywords":"","body":"摄像机 "},"three/section7.html":{"url":"three/section7.html","title":"数学函数","keywords":"","body":"摄像机 "},"three/section8.html":{"url":"three/section8.html","title":"Three.js 对象","keywords":"","body":"摄像机 "},"three/section9.html":{"url":"three/section9.html","title":"渲染器","keywords":"","body":"渲染器 "},"three/section10.html":{"url":"three/section10.html","title":"渲染器 / 着色器","keywords":"","body":"渲染器 / 着色器 "},"three/section11.html":{"url":"three/section11.html","title":"渲染器 / WebGL","keywords":"","body":"渲染器 / WebGL "},"three/section12.html":{"url":"three/section12.html","title":"渲染器 / WebGL / 插件","keywords":"","body":"渲染器 / WebGL / 插件 "},"three/section14.html":{"url":"three/section14.html","title":"场景","keywords":"","body":"场景 "},"three/section15.html":{"url":"three/section15.html","title":"其它","keywords":"","body":"其它 "},"three/section16.html":{"url":"three/section16.html","title":"其它 / 动画","keywords":"","body":"其它 / 动画 "},"three/section17.html":{"url":"three/section17.html","title":"其它 / 核心","keywords":"","body":"其它 / 核心 "},"three/section18.html":{"url":"three/section18.html","title":"其它 / 曲线","keywords":"","body":"其它 / 曲线 "},"three/section19.html":{"url":"three/section19.html","title":"其它 / 几何形状","keywords":"","body":"其它 / 几何形状 立方体 BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) width — X轴上的面的宽度. height — Y轴上的面的高度. depth — Z轴上的面的深度. widthSegments — 可选参数. 沿宽度面的分割面数量. 默认值为1. heightSegments — 可选参数. 沿高度面的分割面数量. 默认值为1. depthSegments — 可选参数. 沿深度面的分割面数量. 默认值为1. 缓存立方体 BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) width — X轴上的面的宽度. height — Y轴上的面的高度. depth — Z轴上的面的深度. widthSegments — 可选参数. 沿宽度面的分割面数量. 默认值为1. heightSegments — 可选参数. 沿高度面的分割面数量. 默认值为1. depthSegments — 可选参数. 沿深度面的分割面数量. 默认值为1. 缓存圆形 CircleBufferGeometry(radius, segments, thetaStart, thetaLength) radius — 圆的半径, 默认值 = 50. segments — 分割面数量 (三角形), 最低值 = 3, 默认值 = 8. thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向). thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi，这形成了一个完整的圆 圆形 CircleGeometry(radius, segments, thetaStart, thetaLength) radius — 圆的半径, 默认值 = 50. segments — 分割面数量 (三角形), 最低值 = 3, 默认值 = 8. thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向). thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi，这形成了一个完整的圆 缓存锥形 ConeBufferGeometry(radius, height, radiusSegments, heightSegments, openEnded, thetaStart, thetaLength) radius — 锥底半径. 默认值为20. height — 锥体高度. 默认值为100. radiusSegments — 围绕圆锥周长的分割面数量. 默认值为8. heightSegments — 沿圆锥高度的分割面数量. 默认值为1. openEnded — 指示锥底是打开还是覆盖的布尔值. 默认值为false, 意思是覆盖. thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向). thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi，这形成了一个完整的锥体. 锥形 ConeGeometry(radius, height, radiusSegments, heightSegments, openEnded, thetaStart, thetaLength) radius — 锥底半径. 默认值为20. height — 锥体高度. 默认值为100. radiusSegments — 围绕圆锥周长的分割面数量. 默认值为8. heightSegments — 沿圆锥高度的分割面数量. 默认值为1. openEnded — 指示锥底是打开还是覆盖的布尔值. 默认值为false, 意思是覆盖. thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向). thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi，这形成了一个完整的锥体. 缓存柱体 CylinderBufferGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded, thetaStart, thetaLength) radiusTop — 圆柱体顶端半径. 默认值为20. radiusBottom — 圆柱体底端半径. 默认值为20. height — 圆柱体高度. 默认值为100. radiusSegments — 围绕圆柱体周长的分割面数量. 默认值为8. heightSegments — 沿圆柱体高度的分割面数量. 默认值为1. openEnded — 指示圆柱体两端是打开还是覆盖的布尔值. 默认值为false, 意思是覆盖. thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向). thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi，这形成了一个完整的圆柱体. 柱体 CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded, thetaStart, thetaLength) radiusTop — 圆柱体顶端半径. 默认值为20. radiusBottom — 圆柱体底端半径. 默认值为20. height — 圆柱体高度. 默认值为100. radiusSegments — 围绕圆柱体周长的分割面数量. 默认值为8. heightSegments — 沿圆柱体高度的分割面数量. 默认值为1. openEnded — 指示圆柱体两端是打开还是覆盖的布尔值. 默认值为false, 意思是覆盖. thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向). thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi，这形成了一个完整的圆柱体. 十二面体 DodecahedronGeometry(radius, detail) radius — 十二面体的半径. 默认值为1. detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个十二面体. "},"three/section20.html":{"url":"three/section20.html","title":"其它 / 帮助","keywords":"","body":"其它 / 帮助 "},"three/section21.html":{"url":"three/section21.html","title":"其它 / 对象","keywords":"","body":"其它 / 对象 "},"jsMetting/":{"url":"jsMetting/","title":"前端面试题","keywords":"","body":"前端面试题 "},"jsMetting/JavaScript.html":{"url":"jsMetting/JavaScript.html","title":"JavaScript面试题","keywords":"","body":"JavaScript面试题 No.1 if (!(\"a\" in window)) { var a = 1; } console.log(a); 解析 在浏览器环境中，全局变量都是window的一个属性，即 var a = 1 等价于 window.a = 1。in操作符用来判断某个属性属于某个对象，可以是对象的直接属性， 也可以是通过prototype继承的属性。再看题目，在浏览器中，如果没有全局变量 a ，则声明一个全局变 量 a (ES5没有块级作用域)，并且赋值为1。很多人会认为打印的是1。非也，大家不要忘了变量声明会被前 置！什么意思呢？题目也就等价于 var a; if (!(\"a\" in window)) { a = 1; } console.log(a); 所以其实已经声明了变量a，只不过if语句之前值是undefined，所以if语句压根不会执行。 最后答案就是 undefined No.2 var a = 1, b = function a(x) { x && a(--x); }; console.log(a); 解析 这道题有几个需要注意的地方： 变量声明、函数声明会被前置，但是函数表达式并不会，准确说类似变量声明前置，举个栗子： console.log('b', b); // b undefined var b = function() {} console.log('b', b); // b function () {} 2.具名的函数表达式的名字只能在该函数内部取到，举个例子(排除老的IE&#x1F602;)： var foo = function bar () {} console.log('foo', foo); // foo function bar(){} console.log('bar', bar); // Uncaught ReferenceError: bar is not defined 综合这两点，再看题目，最后输出的内容就为 1 No.3 function a(x) { return x * 2; } var a; console.log(a); 解析 函数声明会覆盖变量声明，但不会覆盖变量赋值，举个栗子简单粗暴： function foo(){ return 1; } var foo; console.log(typeof foo); // \"function\" 函数声明的优先级高于变量声明的优先级，但如果该变量foo赋值了，那结果就完全不一样了： function foo(){ return 1; } var foo = 1; console.log(typeof foo); // \"number\" 变量foo赋值以后，变量赋值初始化就覆盖了函数声明。这个需要注意 再看题目 function a(x) { return x * 2; } var a; console.log(a); // function a(x) {...} No.4 function b(x, y, a) { arguments[2] = 10; console.log(a); } b(1, 2, 3); 解析 这题考察 arguments 对象的用法(详看&#x1F449;JavaScript中的arguments对象) 一般情况，arguments与函数参数是动态绑定关系(为什么说是一般稍后会解释)，所以很好理解，最后输出 的是10但是但是但是，我们不要忘了一个特殊情况--严格模式，在严格模式中 arguments 与相当于函数参 数的一个拷贝，并没有动态绑定关系，举个栗子： 'use strict' // 严格模式！！ function b(x, y, a) { arguments[2] = 10; console.log(a); } b(1, 2, 3); // 3 No.5 function a() { console.log(this); } a.call(null); 解析 关于 a.call(null); 根据ECMAScript262规范规定： 如果第一个参数传入的对象调用者是null或者undefined的话，call方法将把全局对象（浏览器上是 window对象）作为this的值。所以，不管你什么时候传入null或者 undefined，其this都是全局对象 window。所以，在浏览器上答案是输出 window 对象。但是但是但是，我们依旧不能忘记一个特殊情况-- 严格模式，在严格模式中，null 就是 null，undefined 就是 undefined ，举个栗子： 'use strict'; // 严格模式！！ function a() { console.log(this); } a.call(null); // null a.call(undefined); // undefined "},"jsMetting/react.html":{"url":"jsMetting/react.html","title":"react面试","keywords":"","body":"react面试 "},"IDE/sublime/":{"url":"IDE/sublime/","title":"开发工具","keywords":"","body":"编辑器 "},"IDE/":{"url":"IDE/","title":"sublime","keywords":"","body":"编辑器 "},"IDE/sublime/sublimeKey.html":{"url":"IDE/sublime/sublimeKey.html","title":"sublimeKey","keywords":"","body":"sublime 快捷键 大致比较全的快捷键网址：http://jinguoxing.github.io/sublime/mac/2015/07/02/sublime-mac-keys/有一些我认为用不到，在此我将常用的几个快捷键单独整理一下： 1.)⌘（command）+d 选词（反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑） 2.)⌘（command）+P 搜索项目中的文件 输入当前项目中的文件名，快速搜索文件， 输入@和关键字，查找文件中函数名， 输入：和数字，跳转到文件中该行代码， 输入#和关键字，查找变量名。 (⌘（command）+t)与 ⌘（command）+P 作用一样 3.) ⌘（command）+ W 关闭当前打开文件 4.) ⌘（command）+X 剪切 5.) ⌘（command）+L 选择行，重复可依次增加选择下一行 效果和 Shift+↓ 效果一样 6.) ⌘（command）+O 打开文件 7.)⌘（command) +F 查找内容 8.)⌘（command) +Shift+F 查找并替换 9.)⌘（command) +N 新建窗口 10.)⌘（command) +数字 窗口切换 11.)⌘（command) +K+B 开关侧栏 12.)⌘（command) + / 注释当前行 (单行注释) 13.)alt+ ⌘（command)+/ 当前位置插入注释(多行注释) 14.)按 ⌘（command)键 依次点击或选取，可需要编辑的多个位置 15.)⌘（command）+M 最小化窗口 16.) 1. ⌘（command) + option +2 分成两屏 2. ⌘（command) + option +1 1屏 3. ⌘（command) + option +5 等分四屏 17.)⌘（command) + delelte 删除光标前所有字符 18.)cmd + [或 cmd + ] 智能行缩进 19.) CMD+CTRL+↓或CMD+CTRL+↑ 上下移动当前行。(换位置) 20.) Ctrl+Shift+K 删除整行 21.)command+ k + u 转换大写(将这个词的所有字母转换) 22.)command+ k + l 转换小写。 23.)command+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 24.)command+Enter 在下一行插入新行。举个例子：即使光标不在行尾，也能快速向下插入一行。 25.)command+Shift+Enter 在上一行插入新行。举个例子：即使光标不在行首，也能快速向上插入一行. 26.)command+K+0 展开所有折叠代码。 27.) command+← 向左单位性地移动光标，快速移动光标。 command+→ 向右单位性地移动光标，快速移动光标。 28.) shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 (一个字符一个字符的增加选中，按住 shift键不放，一直点方向键) Shift+→ 向右选中文本。 29.) command+Shift+← 向左单位性地选中文本。 (单位性的我尝试后就是按一行选中，很方便) command+Shift+→ 向右单位性地选中文本。 30.)选中多行： 光标开始处按住shift键不放，到要结束处放下光标 31.)command+J 合并选中的多行代码为一行。举个例子：将多行格式的CSS属性合并为一行。 32.)command+Shift+D 复制光标所在整行，插入到下一行。 33.) Tab 向右缩进。 Shift+Tab 向左缩进。 34.)command+K+K 从光标处开始删除代码至行尾。 35.) command+Z 撤销。 command+Y 恢复撤销。 36.)Esc 退出光标多行选择，退出搜索框，命令框等。 37.)ctrl+` 打开控制台 38.)command + o 弹出当前文件所在的文件夹位置 39.)Ctrl＋Cmd＋G 选中所有同类名称，并可编辑 40.)Cmd+D 只是单纯选中同类名称，不可编辑 "},"IDE/sublime/sublimePlug.html":{"url":"IDE/sublime/sublimePlug.html","title":"sublimePlug","keywords":"","body":"sublime 插件 下载： https://www.sublimetext.com/3 //下载网址，可以选择版本 sublime Text3 以dmp结尾的 删除插件： command+shift+P,输入package 查找remove package 输入你要删除的package 回车，OK 安装插件: 1. 安装 Package Control http://www.jianshu.com/p/5baa47642375 (利用Package Control来安装其他插件) 2. 上面的 Package Control 安装完以后, 就可以通过快捷键 command + shift + p 并输入 install package, 来选择需要安装的插件. 3. 插件有时默认的快捷键会和其他的软件的快捷键冲突，所以可以自己设置插件的快捷键 点击菜单 Preferences -> KeyBindings - User, 加入如下内容 [{ \"keys\": [\"ctrl+1\"], \"command\": \"alignment\" }] 将快捷键修改成自己要改的。 Sublime Text常用插件总结: 我认为插件比较官方了解可以参考此链接：https://packagecontrol.io/packages/Babel 后面换上不同的插件名称即可，不过可能只是大致介绍一些基础重要的。 1.) Emmet Emmet使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度。 具体使用链接：http://www.iteye.com/news/27580 (桌面有两个我写的文件,不过对js和less没有作用) 2.)Alignment 这插件用于对齐代码赋值语句，如 var name = \"sublimt\" var version = \"2.0.1\" var title = \"sublime text 按下快捷键后, 会变成: var name = \"sublimt\" var version = \"2.0.1\" var title = \"sublime text” 3.)Trimmer 你知道当你编写代码时，由于错误或别的某些原因，会产生一些不必要的空格。需要注意的是多余的空格有时也会造成错误。这个插件会自动删除这些不必要的空格，也可以删除空行，可以达到压缩css和js的效果。 4.)autoprefixer 自动在代码前面添加兼容性前缀 例子： 使用前： .wsl{ display:flex; -webkit-border-radius:20px; border-radius:20px; } 使用后： .wsl{ display:-webkit-box; display:-ms-flexbox; display:flex; border-radius:20px; } 注释：效果明显，多于的 CSS/less 会自动删掉，border-radius 早就已经不需要前缀了，只有 Firefox 3.6，Chrome 4，Safari 4 和 Android 2.1 需要前缀； 快捷键设置方式还是如上第三步所示： 5.)Less 功能：LESS高亮插件 简介：用LESS的同学都知道，sublime没有支持less的语法高亮，所以这个插件可以帮上我们 使用：打开.less文件或者设置为less格式 //在没安装这个插件之前less文件中的代码是白色的，看着很不舒服，安装了这个插件则会让代码加上颜色 6.)Babel 这个插件支持ES6， React.js, jsx代码高亮，对 JavaScript, jQuery 也有很好的扩展。 按照上述步骤安装后，在view->Syntax(语法)->这个时候安装了babel就会有一项选择Babel->Babel(javascript)这一项，代码就会变高亮。 （默认是Syntax下面的javascript）。 7.)BracketHighlighter BracketHighlighter插件能为Sublime Text提供括号，引号这类高亮功能，但安装此插件后，默认没有高亮，只有下划线表示，不是很醒目，跟进一步的修改可以 http://www.wdclab.com/2015/09/10/mac%E7%89%88sublime-text-3%E4%B8%ADbrackethighlighter%E6%8F%92%E4%BB%B6%E9%AB%98%E4%BA%AE%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/ (mac) http://www.cnblogs.com/willingtolove/p/4657320.html (windows) 可以参考此链接 ,很有用,执行完第二步是白色高亮 若想彩色高亮则根据步骤继续进行第三步。 , Bracket Quote 表示引号 Bracket Tag 表示标签 Bracket Angle 表示角 （这个可以自己试试） Bracket Square 表示方括号 Bracket Round 表示小括号 Bracket Curly 表示大括号 不过实现彩色的效果还需要安装SublimeLinter {主题相关插件8-9} 8.)Theme-Soda Soda主题是sublime上一款很著名的清爽型主题，分两种： light: dark: 两者之间的切换通过在 （菜单 Preferences -> Settings - User）中加入 \"theme\": \"Soda Light.sublime-theme\" 或 \"theme\": \"Soda Dark.sublime-theme” 如果想要原来默认的则去掉这句话不写即可，默认： 保存之后发现怎么代码区域还是黑色的背景，菜单栏颜色已经切换了，别急，这里还少了一步，就是配置一下color scheme,就用下面的插件介绍 9.)ColorSublime 主题可以参考此链接： http://www.jianshu.com/p/13fedee165f1 主要以ColorSublime为插件安装 安装了ColorSublime后，在控制面板里输入安装ColorSublime:install theme 就可以如链接所示，选择你相中的主体安装 {文件模版10} 10.)SublimeTmpl http://www.fantxi.com/blog/archives/sublime-template-engine-sublimetmpl/只看使用，安装就行，Sublime Text 新建文件的模版插件 {JS代码格式化11} 11.)JsFormat 这是一款将JS格式化的插件，安装后即可在JS文件中通过鼠标右键->JsFormat或键盘快捷键Ctrl+Alt+F对JS进行格式化 {右键菜单功能增强插件12} 12.)SideBarEnhancements 这是一款很实用的右键菜单增强功能，安装之前左侧菜单栏右键只有几个功能，安装之后增加了很多实用功能。 可以参考这个链接，有个简单的说明：https://nicesu.gitbooks.io/sublime-text-guide/content/plug-in/sidebarenhancements.html {只针对.css的文件代码排序13} 13.)CSScomb 格式化前： , 格式化后：快捷键 ctrl+shift+c , 但是会产生一些空行，可以解决: 在sublime中下载CSS Format插件，然后执行 edit->css format->expanded 即可此 时空行将会消除。 , 我认为可以先用css最后可以改成less文件可以参考这个链接：https://segmentfault.com/a/1190000004577644 {文件中打开命令行窗口14} 14.)Terminal 在编程过程中我们需要经常使用到命令行窗口，此快捷键可以在sublime Text3中打开cmd窗口，默认打开的是终端，如果想要打开iTerm,可以在setting->user中设置： 快捷键（mac）:cmd+shift+t 可以参考链接：https://packagecontrol.io/packages/Terminal {查看html、css兼容的15} 15.)Can I Use 不过只是针对html和css，选中一个词或标签按快捷键：ctrl+alt+f就会跳到http://caniuse.com/，可以看到兼容到哪些浏览器 {代码校验16} 16.)SublimeLinter SublimeLinter是一个代码校验插件，它可以帮你找出错误或编写不规范的代码 会在页面上产生一些点，点击点会有提示在下方 可以按照这个安装： http://www.cnblogs.com/xiaofeixiang/p/4853625.html 可以通过这个研究： https://nicesu.gitbooks.io/sublime-text-guide/content/plug-in/sublimelinter.html (但是不知道怎么把下面提示区域放大？) {在文件中调用Git命令17} 17.)Git 可以参考此链接：https://packagecontrol.io/packages/Git 安装完git后可以在mac中用命令打开：cmd+shift+p，输入git就会出现很多git命令。 (但是git status可以用，其他的怎么用？) "},"IDE/atom.html":{"url":"IDE/atom.html","title":"atom","keywords":"","body":"atom 一、快捷键部分 A:光标及选取部分 行部分： cmd+up 光标移动至文件开始处 cmd+down 光标移动至文件结束处 cmd+click 多行同时输入 cmd+l 选取此行 ctrl+shift+n 选取下一行 ctrl+shift+p 选取下一行 cmd+shift+left 选取至此行开始处 cmd+shift+right 选取至此行结束处 cmd+shift+up 选取至文件开始 cmd+shift+down 选取至文件结尾 单词(字符)部分： cmd+shift+w 选中此单词 alt+shift+left 选取至此单词开始处 alt+shift+right 选取至此单词结束处 cmd+d 选取文件中和当前单词相同的下一处并增加光标 ctrl+cmd+g 选取文档中所有和当前光标单词相同的位置并增加光标 括号部分： ctrl-m 相应括号之间，html tag之间等跳转 ctrl-cmd-m 括号(tag)之间文本选取 B:编辑操作 行部分： cmd-J 将下一行与当前行合并ctrl-cmd-up, ctrl-cmd-down 使当前行向上或者向下移动cmd-shift-D 复制当前行到下一行ctrl-K 剪切到当前行结束ctrl-shift-K 删除当前行cmd-backspace 删除到当前行开始cmd-fn-backspace 删除到当前行结束 字符(单词)部分： ctrl-T 使光标前后字符交换 alt-backspace 或 alt-H 删除到当前单词开始 alt-delete 或 alt-D 删除到当前单词结束 cmd-K+cmd-U 使当前字符大写 cmd-K+cmd-L 使当前字符小写 C:功能部分 cmd+, 打开setting control+tab 切换标签页 control+数字 切换标签页 忽略文件显示更改： setting=>open config Folder=>config.cson=>最后那个h开头的改为false 二、atom实用插件 1 Emmet 用法：Ctrl+Alt+Enter 2 Atom Beautify 代码优化 3 Minimap sublime右上角代码缩略图 4 file-icons 文件图标 5 atom-ternjs js代码提示 6 atom-react-autocomplete jsx代码提示 "},"IDE/vim.html":{"url":"IDE/vim.html","title":"vim","keywords":"","body":"vim 的基本概念 vim大致分可为这么几种状态，分别是命令模式、插入模式、视图模式、和底行模式，各模式的功能区分如下： 1) 命令行模式 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段 2) 插入模式 按 i 进入插入模式,对文件的内容进行编辑操作，按 ESC 键可回到命令行模式 3) 视图模式 按 v 或者 V 进入视图模式，对文字区段进行选择,然后进行相应的操作（比如复制一段文字，删除一段文字等等） 4) 底行模式 按 : 或者 / 进入底行模式,其实底行模式也是命令模式的一种等 常使用底行模式对文件文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等 基本命令 1) 命令行模式 h 向左移动光标 j 向下移动光标 k 向上移动光标 l 向右移动光标 0 移到文件的开头 G 移动到文件的最后 $ 移动到光标所在行的“行尾” ^ 移动到光标所在行的“行首” w 光标跳到下个字的开头 e 光标跳到下个字的字尾 b 光标回到上个字的开头 nl 光标移到该行的第n的位置，其中n是数字 如：5l 将光标移动到当前行的第5个字符处 x 每按一次，删除光标所在位置的“后面”一个字符 nx 删除光标所在位置的“后面”n个字符,n是数字,比如 5x X 删除光标所在位置的“前面”一个字符 nX 删除光标所在位置的“前面”n个字符,n是数字,比如 5X dd 删除光标所在行 ndd 从光标所在行开始删除n行 yw 将光标所在之处到字尾的字符复制到缓冲区中 nyw 复制n个字到缓冲区 yy 复制光标所在行到缓冲区 nyy 例如，6yy表示拷贝从光标所在的该行“往下数”6行文字 p 将缓冲区内的字符贴到光标所在位置注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能 r 替换光标所在处的字符 R 替换光标所到之处的字符，直到按下「ESC」键为止 u 如果您误执行一个命令，可以马上按下「u」，回到上一个操作按多次“u”可以执行多次回复 cw 更改光标所在处的字到字尾处 cnw 例如，c3w表示更改3个字,其中n是数字 nG(或者ngg)例如，15G表示移动光标至文件的第15行的行首,其中n是数字 ctrl+g 列出光标所在行的行号 ci”清除引号内容 ci> 清除尖括号内容 cit 清除标签内的内容 zc 折叠 zC 对所在范围内所有嵌套的折叠点进行折叠 zo 展开折叠 zO 对所在范围内所有嵌套的折叠点展开 [z 到当前打开的折叠的开始处 ]z 到当前打开的折叠的末尾处 zj 向下移动,到达下一个折叠的开始处,关闭的折叠也被计入 zk 向上移动到前一折叠的结束处,关闭的折叠也被计入 xp 交换两个字符的位置 ddp 上下两行调换 移动屏幕 ctrl+g 列出光标所在行的行 ctrl+b 屏幕往“后”移动一页 ctrl+f 屏幕往“前”移动一页 ctrl+u 屏幕往“后”移动半页 ctrl+d 屏幕往“前”移动半页 shift +3 选中并查找该词组 跳转位置 ctrl+o 回到更老的跳转位置 ctrl+i 向前跳转位置(两个命令前面可以加数字来表示倍数) 改变大小写 ~ 将光标下的字母改变大小写 3~ 将光标位置开始的3个字母改变其大小写 g~~ 改变当前行字母的大小写 U 将可视模式下选择的字母全改成大写字母 u 将可视模式下选择的字母全改成小写 gUU 将当前行的字母改成大写 3gUU 将从光标开始到下面3行字母改成大写 guu 将当前行的字母全改成小写 gUw 将光标下的单词改成大写。 guw 将光标下的单词改成小写。 2) 插入模式 i 在光标的前面插入字符 I 在当前行的第一个字符前插入字符 o 在当前行的下一行插入新的一行,并在新的一行的第一个字符处插入字符 O 在当前行的上一行插入新的一行,并在新的一行的第一个字符处插入字符 a 在光标的后面插入字符 A 在当前行的最后面插入字符 按[Esc]回到命令模式 3) 视图模式 vi” 选择引号内容 vi> 选择尖括号内容 vit 选择标签内的内容 va” 选择包括引号在内的内容 va> 选择包括尖括号在内的内容 vat 选择整个标签 4) 底行模式 :w filename 将文件以指定的文件名filename保存 :wq 存盘并退出vim :q! 不存盘强制退出vim :set nu 显示行号 :15 回车，跳到文件第15行 /关键字, 先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止 ?关键字, 先按「?」键，再输入您想寻找的字符，如果第一次找的关键字ä¡ :-n,+n d '-'表示当前行的上n行，'+'表示当前行的下n行,比如命令':-2,+2 d'的意思，就是说删除但前行的上2行到当前行的下2行 :n pu 将剪切板中的内容粘贴到n行 :e filename 在当前编辑的窗口中打开指定的“filename”的文件进行编辑操作 :p 文件操作，前一个文件 :n 文件操作，下一个文件 :last 文件操作，最后一个文件 :!cmd 执行shell命令 :sh 进入shell :exit 退出shell 按[Esc]回到命令模式 "},"IDE/vsCode.html":{"url":"IDE/vsCode.html","title":"vsCode","keywords":"","body":"vsCode 编辑器 相关文档 "},"IDE/Git.html":{"url":"IDE/Git.html","title":"Git","keywords":"","body":"Git 查看、添加、提交、删除、找回，重置修改文件 git help # 显示command的help git show # 显示某次提交的内容 git show $id git co -- # 抛弃工作区修改 git co . # 抛弃工作区修改 git add # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm # 从版本库中删除文件 git rm --cached # 从版本库中删除文件，但不删除文件 git reset # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am \"some comments\" git ci --amend # 修改最后一次提交记录 git revert # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diff git diff # 比较当前文件和暂存区文件差异 git diff git diff # 比较两次提交之间的差异 git diff .. # 在两个分支之间比较 git diff --staged # 比较暂存区和版本库差异 git diff --cached # 比较暂存区和版本库差异 git diff --stat # 仅仅比较统计信息 查看提交记录 git log git log # 查看该文件每次提交记录 git log -p # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log --stat #查看提交统计信息 tig Mac上可以使用tig代替diff和log，brew install tig Git 本地分支管理 查看、切换、创建和删除分支 git br -r # 查看远程分支 git br # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br --merged # 查看已经被合并到当前分支的分支 git br --no-merged # 查看尚未被合并到当前分支的分支 git co # 切换到某个分支 git co -b # 创建新的分支，并且切换过去 git co -b # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b # 把某次历史提交记录checkout出来，创建成一个分支 git br -d # 删除某个分支 git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase git merge # 将branch分支合并到当前分支 git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master # 将master rebase到branch，相当于： git co && git rebase master && git co master && git merge Git补丁管理(方便在多台机器上开发同步时用) git diff > ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理 git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理 git pull # 抓取远程仓库所有分支更新并合并到本地 git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b origin/ # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin # 创建远程分支， origin是远程仓库名 git push origin : # 创建远程分支 git push origin : #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理 GitHub git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库 git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git && cd robbin_site.git && git --bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 git branch --set-upstream master origin/master git branch --set-upstream develop origin/develop "},"help/":{"url":"help/","title":"帮助文档","keywords":"","body":"帮助文档 "},"help/Markdown.html":{"url":"help/Markdown.html","title":"Markdown","keywords":"","body":"Markdown 语法 一级标题 # 一级标题 二级标题 ## 二级标题 三级标题 ### 三级标题 四级标题 #### 四级标题 五级标题 ##### 五级标题 六级标题 ###### 六级标题 插入链接 [链接名称](链接地址) 插入图片 ![图片标题](图片链接地址) 段落引用 Markdown是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 >Markdown是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 段落嵌套 Markdown是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 锤子科技15年8月发布会上，老罗宣布锤子便签支持Markdown语法。我们可大胆预测，使用Markdown语法在移动端编辑会逐渐成为趋势。 >Markdown是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 >>锤子科技15年8月发布会上，老罗宣布锤子便签支持Markdown语法。我们可大胆预测，使用Markdown语法在移动端编辑会逐渐成为趋势。 强调语法 斜体 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号 *斜体* 加粗 **加粗** 删除线 ~~删除线~~ 行内标记 行内标记用反引号把它包起来''，例如： 这是一个金色的秋天 这是一个`金色`的秋天 自动邮箱链接 *****@163.com 加强代码块 for (var i = 0; i 列表 无序列表使用星号、加号或是减号作为列表标记，效果一样： 星号 加号 减号 * 星号 + 加号 - 减号 有序列表则使用数字接着一个英文句点： 1.你好 2.我好 3.他好 1.你好 2.我好 3.他好 代码区块 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入 holle world holle world 加强代码块 使用“```”+“语言名称”进行标记 for (var i = 0; i 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： *** --- * * * 脚注（footnote） 效果： hello1 1. hi ↩ hello[^1] [^1]: hi 表格 项目 类型 框架 kr-admin pc react 左对齐 居中 右对齐 |项目|类型|框架| |-----|:-----:|-----:| |kr-admin|pc|react| |左对齐|居中|右对齐| "},"recommended/":{"url":"recommended/","title":"推荐网站","keywords":"","body":"推荐网站 threejs中文网站 gitbook教程 electron学习 Redux学习 Vuex学习 vue-router2学习 ReactRouter学习 reactVR webpack学习 mobx svg "}}